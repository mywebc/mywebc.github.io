[{"categories":null,"content":" 前一段时间一直在看Java，一直没有总结，今天总结下spring boot如何快速入门。 ","date":"2021-10-17","objectID":"/springboot%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:0:0","tags":["java"],"title":"springboot如何快速入门","uri":"/springboot%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"前置条件 学习Java，环境当然要装，以下几个直接无脑装。 jdk - java开发环境能够编译运行java maven - java中的包管理类似于npm mysql - 数据库本地安装或者使用Docker安装 idea - 开发工具没得说 ","date":"2021-10-17","objectID":"/springboot%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:0:1","tags":["java"],"title":"springboot如何快速入门","uri":"/springboot%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"项目新建 项目新建有两种方式, 官网的生成器 和 idea自带的Spring Initializar 官网的Spring Initializar 进去后，java版本改为8（稳定），web开发需要加一个依赖spring web,其他一切默认就好，然后直接点击GERERATE下载就好，idea直接打开; idea的Spring Initializar 使用idea自带的Spring Initializar也是很方便的 先创建一个project，选择Spring Initializar; 同样版本选为8，next; 加个spring web的依赖，一路next到底结束; 很顺利的最后的目录结构应该是这样 ","date":"2021-10-17","objectID":"/springboot%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:0:2","tags":["java"],"title":"springboot如何快速入门","uri":"/springboot%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"项目运行 springboot是一个开箱即用的框架，目前为止我们新建的项目已经可以运行了，我们可以写个接口测试以下; 首先在com.example.demo下新建controller包，不要问为什么，问回答这就是约定; 在controller下新建一个DemoController的类，类的内容如下： @Controller public class DemoController { @GetMapping(\"/test\") @ResponseBody public String testDemo() { return \"这是第一个接口\"; } } 首先看到@第一反应是不是很像装饰器，其实是两码事，你可以认为这个注解只是springboot跟你的一个约定，一个标记而已，而装饰器则会直接改变行为。 @Controller: 定义类为控制类，一般接口就由控制类来转发; @GetMapping： 顾名思义该接口由get请求，举一反三还有个@PostMapping; @ResponseBody: 定义方法返回json的数据格式; springboot的注解还有很多，在此就不一一例举了，等到用到什么再去查就好了; 完成以上工作直接运行DemoApplication类就好了，然后浏览器直接访问localhost:8080/test，就能看到我们这个接口返回的字符串了; 测试下github actions ","date":"2021-10-17","objectID":"/springboot%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:0:3","tags":["java"],"title":"springboot如何快速入门","uri":"/springboot%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":" 最近在写一些Vue和React相关的组件库，涉及到打包文件发布npm这一块，在对比了webpack和rollup两种打包工具之后，决定使用rollup来打包，在此总结一下，希望可以给其他人参考。如果嫌我啰嗦，可以直接看代码，😊。 ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:0:0","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"Rollup Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，常用于打包类库，其配置项也非常的简洁,跟webpack其实差不多，一个最基本的配置格式大体如下： export default { // 入口 input: \"\", // 输出 output: [], // 排除项 external: [], // 全局模块 globals: {}, // 插件 plugins: [], } ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:1:0","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"与webpack区别 ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:2:0","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"Rollup 简洁的API，易上手; 天生的Tree-shaking，自动删除冗余代码; 支持多模块导出; 能快速打出体积更小的bundle; 适合打包类、库； ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:2:1","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"webpack 丰富的插件系统; 代码分割和静态资源导入; 热模块更新; 适合项目级应用; ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:2:2","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"React react 打包配置如下，大家可以根据自己的项目稍微修改下即可。 import resolve from 'rollup-plugin-node-resolve'; import postcss from 'rollup-plugin-postcss'; import commonjs from 'rollup-plugin-commonjs'; import babel from 'rollup-plugin-babel'; import typescript from '@rollup/plugin-typescript'; const extensions = ['.js', '.jsx', '.ts', '.tsx']; export default { input: 'src/components/index.tsx', output: [ { name: 'index', format: 'es', file: 'dist/lib/react.esm.js' }, { name: 'index', format: 'umd', file: 'dist/lib/react.js' } ], external: ['react', 'react-dom'], globals: { react: 'React', \"react-dom\": \"ReactDOM\", }, plugins: [ resolve({ mainFields: ['module', 'main', 'jsnext:main', 'browser'], extensions }), babel({ exclude: '**/node_modules/**', runtimeHelpers: true }), commonjs({ include: \"node_modules/**\" }), postcss({ extract: true, extensions: ['.scss'] }), typescript() ], }; ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:3:0","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"Vue vue 打包如下。 import esbuild from 'rollup-plugin-esbuild' import vue from 'rollup-plugin-vue' import scss from 'rollup-plugin-scss' import dartSass from 'sass'; import { terser } from \"rollup-plugin-terser\" export default { input: 'src/lib/index.ts', output: [{ globals: { vue: 'Vue' }, name: 'vue', file: 'dist/lib/vue.js', format: 'umd', plugins: [terser()] }, { name: 'vue', file: 'dist/lib/vue.esm.js', format: 'es', plugins: [terser()] }], plugins: [ scss({ include: /\\.scss$/, sass: dartSass }), esbuild({ include: /\\.[jt]s$/, minify: process.env.NODE_ENV === 'production', target: 'es2015' }), vue({ include: /\\.vue$/, }) ], } ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:4:0","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"发布npm ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:5:0","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"修改或添加package.json一些选项 { \"name\": \"你的组件库名字\", \"version\": \"组件库版本\", \"files\": [ \"dist/lib/*\" ], \"main\": \"dist/lib/bundle.js\", \"module\": \"dist/lib/bundle.esm.js\" } ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:5:1","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"切换npm官方源 // 查看 npm config get registry // 设置 npm config set registry https://registry.npm.taobao.org ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:5:2","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"发布 // 必须先登录 npm login npm publish ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:5:3","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["工具"],"content":"注意 保证库的名字唯一 保证每次发布的版本号不一样 ","date":"2020-11-29","objectID":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/:5:4","tags":["RollupJs","npm"],"title":"使用Rollup打包Vue或React组件库并发布到npm","uri":"/%E4%BD%BF%E7%94%A8rollup%E6%89%93%E5%8C%85vue%E6%88%96react%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0npm/"},{"categories":["java"],"content":" 在java中，代码是阻塞同步执行的，为了更好的利用CPU资源，多线程的使用是十分有必要的，与之相关的，不得不提的还有一个进程，所谓进程即是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。而线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程资源； ","date":"2020-07-09","objectID":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/:0:0","tags":["java"],"title":"Java之多线程初步总结","uri":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"并发与并行 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。 ","date":"2020-07-09","objectID":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/:1:0","tags":["java"],"title":"Java之多线程初步总结","uri":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"线程创建 在 Java 中使用 Thread 类代表线程，所有的线程对象都必须是 Thread 类或者其子类的实例，Java 中创建线程主要有以下三种方式： ","date":"2020-07-09","objectID":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/:2:0","tags":["java"],"title":"Java之多线程初步总结","uri":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"继承 Thread 类 public class CreateThreadByExtendsThread extends Thread { @Override public void run() { IntStream.rangeClosed(1, 10).forEach(i -\u003e System.out.println(Thread.currentThread().getName() + \" \" + i)); } public static void main(String[] args) { CreateThreadByExtendsThread threadOne = new CreateThreadByExtendsThread(); threadOne.start(); } } ","date":"2020-07-09","objectID":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/:2:1","tags":["java"],"title":"Java之多线程初步总结","uri":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"实现 Runnable 接口 public class RunableTest implements Runnable { @Override public void run() { while (true) { System.out.println(\"good time\"); } } public static void main(String[] args) { RunableTest runableTest1 = new RunableTest(); new Thread(runableTest1).start(); } } ","date":"2020-07-09","objectID":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/:2:2","tags":["java"],"title":"Java之多线程初步总结","uri":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"实现 Callable 接口 public class CallTest implements Callable { @Override public Object call() throws Exception { return \"hello world\"; } public static void main(String[] args){ FutureTask\u003cString\u003e futureTask = new FutureTask\u003cString\u003e(new CallTest()); new Thread(futureTask).start(); try { String result = futureTask.get(); System.out.println(result); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } ","date":"2020-07-09","objectID":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/:2:3","tags":["java"],"title":"Java之多线程初步总结","uri":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"多线程的优点 提高CPU的利用率 对于IO密集型极其有用（网络IO，文件IO） CPU性能100%的提升 程序设计更简单 ","date":"2020-07-09","objectID":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/:3:0","tags":["java"],"title":"Java之多线程初步总结","uri":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"多线程带来的问题 大量的线程,会影响性能,因为操作系统需要在它们之间切换 更多的线程需要更多的内存空间 线程中止需要考虑对程序运行的影响 通常块模型数据是在多个线程间共享的,需要防止线程死锁情况的发生 ","date":"2020-07-09","objectID":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/:4:0","tags":["java"],"title":"Java之多线程初步总结","uri":"/java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":" Java中的数组有很多弊端，长度固定，不可增加删除操作，只能存储同一种数据类型，而且数组内元素的内存空间是连续分配的，对内存要求高点；而Java中的集合弥补了这一点，在Java中的集合可分为两大类collection和map,对此我们对集合有不同的需求，就产生了不同的实现； Collection（单列集合） ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:0:0","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"List List接口是一个有序集合，允许有相同的元素。 ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:1:0","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"ArrayList 最常用的实现类，线性结构，本质上就是一个数组，通过动态扩容实现添加元素（创建一个更大的空间。然后把原先的所有元素拷贝过去）； ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:1:1","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"LinkedList 底层为链表。特点即分配内存空间不是必须是连续的，插入、删除操作很快，只要修改前后指针就OK了，时间复杂度为O(1)； ArrayList和LinkedList区别 ArrayList它支持以角标位置进行索引出对应的元素(随机访问)，而LinkedList则需要遍历整个链表来获取对应的元素。因此一般来说ArrayList的访问速度是要比LinkedList要快的 ArrayList由于是数组，对于删除和修改而言消耗是比较大(复制和移动数组实现)，LinkedList是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此一般来说LinkedList的增删速度是要比ArrayList要快的； ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:1:2","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"Vector（了解） 底层数据结构是数组。和ArrayList 很相似，但是两者是不同的： Vector 是同步访问的。 Vector 包含了许多传统的方法，这些方法不属于集合框架。 ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:1:3","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"Set Set没有顺序 Set不能包含重复元素 ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:2:0","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"HashSet 最常用的实现，底层是哈希表(是一个元素为链表的数组)； List.add(1); List.add(1); List.add(2); Set\u003cInteger\u003e newSet = HashSet\u003c\u003e(List); 注意此实现是无序的。 ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:2:1","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"LinkedHashSet 底层数据结构由哈希表和链表组成。 保证内部顺序和插入的顺序一样。 ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:2:2","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"TreeSet 底层数据结构是红黑树（可以认为是左小右大的二叉树） 缺省是按照自然顺序进行排序，TreeSet中的元素要实现Comparable接口，或者有一个自定义的比较器Comparator。 Map（key-value集合） Map即为映射，不能包含重复的键，可以包含重复的值； ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:2:3","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"HashMap HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。 HashMap\u003cString , Integer\u003e map = new HashMap\u003cString , Integer\u003e(); map.put(\"年龄\" , 24); HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。 当程序执行 map.put(“年龄” , 24); 时，系统将调用\"年龄\"的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置。 ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:2:4","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":"TreeMap（了解） HashMap和HashSet本质上是⼀种东⻄（红黑树）： ","date":"2020-06-26","objectID":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/:2:5","tags":["java"],"title":"Map集合和Collection集合常用类的总结","uri":"/map%E9%9B%86%E5%90%88%E5%92%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["java"],"content":" java中的包就是一些第三方的类库，跟前端的npm包差不多，前端通过npm这个平台管理npm包，在java中通过maven来实现包管理。 ","date":"2020-06-22","objectID":"/java%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/:0:0","tags":["java"],"title":"Java的包管理","uri":"/java%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/"},{"categories":["java"],"content":"maven的包管理 传递依赖的包的自动管理 依赖冲突的自动解决 - 就近原则 包的作用域（scope） ","date":"2020-06-22","objectID":"/java%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/:1:0","tags":["java"],"title":"Java的包管理","uri":"/java%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/"},{"categories":["java"],"content":"关于pom.xml （Project Object Model） pom.xml是maven用来管理包的配置文件，与前端使用npm包生成的package.json文件类似。 一份简单的pom.xml配置 \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003egroupID\u003c/groupId\u003e \u003cartifactId\u003eartifactId\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cpackaging\u003e...\u003c/packaging\u003e \u003cname\u003e...\u003c/name\u003e \u003curl\u003e...\u003c/url\u003e \u003cproperties\u003e...\u003c/properties\u003e \u003c!-- 依赖关系 --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.0\u003c/version\u003e \u003ctype\u003ejar\u003c/type\u003e \u003cscope\u003etest\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--构建设置 --\u003e \u003cbuild\u003e...\u003c/build\u003e \u003c/project\u003e 其中必须的三元素： 项目组( groupId )，项目名称( artifactId )及其版本( version )。 packaging:打包机制，如pom,jar,maven-plugin,ejb,war,ear,rar,par name:自定义名称 可选 url:自定义网站，可选 properties:是为pom定义一些常量。 关于dependencies type：默认为jar类型，常用的类型有：jar,ejb-client,test-jar…, scope：是用来指定当前包的依赖范围， optional:设置指依赖是否可选，默认为false, ","date":"2020-06-22","objectID":"/java%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/:2:0","tags":["java"],"title":"Java的包管理","uri":"/java%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/"},{"categories":["java"],"content":"包冲突的解决方案 包冲突的错误一般会报如下错误 AbstractMethodError NoClassDefFoundError ClassNotFoundException LinkageError maven的自动处理 maven会采取就近原则自动帮我们处理。 手动排除 使用mvn dependency:tree命令分析，在pom.xml中使用 exclusion 标签去排除冲突的jar包。 Maven Helper插件（推荐） idea中安装Maven Helper插件，使用插件分析冲突的包，自动添加 exclusion 。 ","date":"2020-06-22","objectID":"/java%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/:3:0","tags":["java"],"title":"Java的包管理","uri":"/java%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/"},{"categories":["blog"],"content":" 最近把博客从hexo搬到了hugo，感觉确实比hexo快了不少，尤其是在部署的时候，直接push就好了，关于hugo的教程网上有很多，本篇文章也是自己(mac)的一份总结。 ","date":"2020-06-19","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","tags":["hugo"],"title":"hugo博客搭建","uri":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["blog"],"content":"hugo下载 mac系统,下载可能会很慢 brew install hugo 如果下载很慢，可以直接去GitHub下载 https://github.com/gohugoio/hugo/releases 查看版本 hugo version 出现版本信息则安装成功。 ","date":"2020-06-19","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","tags":["hugo"],"title":"hugo博客搭建","uri":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["blog"],"content":"创建site 创建一个site,名称最好使用你的GitHub名称，比如yourGithubName.github.io hugo new site yourGithubName.github.io 进入这个目录，创建一篇文章 hugo new posts/test.md 此时会在content目录下创建一个目录posts，下面创建一篇文章test.md。 test.md内会是这样,draft为true表示草稿状态，要发布时改为false即可 --- title: test.md date: xxxxxxxxx draft: true --- ","date":"2020-06-19","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","tags":["hugo"],"title":"hugo博客搭建","uri":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["blog"],"content":"关于主题 关于主题，我使用的是这个LeaveIt主题，具体使用GitHub上有详细的教程。 ","date":"2020-06-19","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","tags":["hugo"],"title":"hugo博客搭建","uri":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["blog"],"content":"本地浏览 使用hugo server本地浏览 hugo server ","date":"2020-06-19","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:0","tags":["hugo"],"title":"hugo博客搭建","uri":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["blog"],"content":"发布到GitHub 删除原有hexo的仓库，重新创建一个新仓库格式仍然是 你的用户名.github.io。 执行hugo,这时候会在当前目录下生成public文件夹 cd到public文件夹，将此文件夹的所有内容push到刚刚创建的仓库即可。 ","date":"2020-06-19","objectID":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:0","tags":["hugo"],"title":"hugo博客搭建","uri":"/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":" 最近node.js之父又搞了个Deno.js，同样是基于V8引擎，据说对比node.js改进了不少，周末有时间就来体验了一下。 ","date":"2020-05-24","objectID":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/:0:0","tags":["Deno"],"title":"Deno 初体验","uri":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"安装 安装 curl -fsSL https://deno.land/x/install/install.sh | sh 编辑bash_profile文件 vi ~/.bash_profile 添加环境变量 export DENO_INSTALL=\"/Users/yourName/.deno\" export PATH=\"$DENO_INSTALL/bin:$PATH\" 执行 source ~/.bash_profile ","date":"2020-05-24","objectID":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/:0:1","tags":["Deno"],"title":"Deno 初体验","uri":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"体验 打印 Welcome to Deno 新建deno.ts console.log(\"Welcome to Deno\") 运行deno run deno.ts命令 deno run deno.ts 当然也可以直接运行 deno run https://deno.land/std/examples/welcome.ts ","date":"2020-05-24","objectID":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/:0:2","tags":["Deno"],"title":"Deno 初体验","uri":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"支持typescript const _name: string = \"jack\"; const _age: number = ((): number =\u003e (Math.floor(Math.random() * 100)))() console.log(`名字是${_name},年龄是${_age}`) ","date":"2020-05-24","objectID":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/:1:0","tags":["Deno"],"title":"Deno 初体验","uri":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"模块引入与浏览器一致 原先Common.js模块变为ES模块 ","date":"2020-05-24","objectID":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/:2:0","tags":["Deno"],"title":"Deno 初体验","uri":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"增加权限 增加一些权限 比如运行一下文件需要加上–allow-net deno run --allow-net https://deno.land/std/examples/echo_server.ts ","date":"2020-05-24","objectID":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/:3:0","tags":["Deno"],"title":"Deno 初体验","uri":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"自身内置测试打包工具 这个就不演示了，具体看官方文档中的examples ","date":"2020-05-24","objectID":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/:4:0","tags":["Deno"],"title":"Deno 初体验","uri":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"结尾 deno还有很多的特性没列出来，本文只是简单的大致体验了下deno。 ","date":"2020-05-24","objectID":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/:5:0","tags":["Deno"],"title":"Deno 初体验","uri":"/deno-%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["工具"],"content":" 需求：原先做的app端又增加了pc端，现在把他们放在同一个项目下，就需要我们配置多入口了。 原先页面为index.html,后面增加pcJs.html ","date":"2019-12-08","objectID":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/:0:0","tags":["webpack"],"title":"webpack配置app和pc多入口","uri":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/"},{"categories":["工具"],"content":"更改路径 在paths.js里 { // 增加pc的html pcIndexJs: resolveModule(resolveApp, 'src/pc/index'), } ","date":"2019-12-08","objectID":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/:1:0","tags":["webpack"],"title":"webpack配置app和pc多入口","uri":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/"},{"categories":["工具"],"content":"增加entry 在webpack.config.js下 entry: { index: [ isEnvDevelopment \u0026\u0026 require.resolve(\"react-dev-utils/webpackHotDevClient\"), paths.appIndexJs ].filter(Boolean), pcJs: [ isEnvDevelopment \u0026\u0026 require.resolve(\"react-dev-utils/webpackHotDevClient\"), paths.pcIndexJs ].filter(Boolean) }, ","date":"2019-12-08","objectID":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/:2:0","tags":["webpack"],"title":"webpack配置app和pc多入口","uri":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/"},{"categories":["工具"],"content":"动态生成文件名 在webpack.config.js下 output: { filename: isEnvProduction ? \"static/js/[name].[contenthash:8].js\" : isEnvDevelopment \u0026\u0026 \"static/js/[name].bundle.js\", // TODO: remove this when upgrading to webpack 5 futureEmitAssets: true, // There are also additional JS chunk files if you use code splitting. chunkFilename: isEnvProduction ? \"english/static/js/[name].[contenthash:8].chunk.js\" : isEnvDevelopment \u0026\u0026 \"static/js/[name].chunk.js\", } ","date":"2019-12-08","objectID":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/:3:0","tags":["webpack"],"title":"webpack配置app和pc多入口","uri":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/"},{"categories":["工具"],"content":"动态生成对应HTML 在webpack.config.js下 plugins: [ new HtmlWebpackPlugin( Object.assign( {}, { inject: true, template: paths.appHtml, chunks: [\"index\"], inject: true, filename: \"index.html\" }, isEnvProduction ? { minify: { removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true } } : undefined ) ), new HtmlWebpackPlugin( Object.assign( {}, { inject: true, template: paths.appHtml, chunks: [\"pcJs\"], inject: true, filename: \"pcJs.html\" }, isEnvProduction ? { minify: { removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true } } : undefined ) ), ] ","date":"2019-12-08","objectID":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/:4:0","tags":["webpack"],"title":"webpack配置app和pc多入口","uri":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/"},{"categories":["工具"],"content":"路由重指向 在webpackDevServer.config.js下 historyApiFallback: { // Paths with dots should still use the history fallback. // See https://github.com/facebook/create-react-app/issues/387. disableDotRule: true, // pc开头全部指向pcJs.html rewrites: [{ from: /^\\/pc/, to: \"/pcJs.html\" }] }, 重定向时to的后面，不需要加build! ","date":"2019-12-08","objectID":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/:5:0","tags":["webpack"],"title":"webpack配置app和pc多入口","uri":"/webpack%E9%85%8D%E7%BD%AEapp%E5%92%8Cpc%E5%A4%9A%E5%85%A5%E5%8F%A3/"},{"categories":["React"],"content":" 不知哪天随手点开了一篇react portals的文章,眼前一亮,竟然还没有我听说过的react的特性,在看了大概之后,并没有觉得有什么用,不过最近在做开发时,还正好和需求对上了. ","date":"2019-09-28","objectID":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/:0:0","tags":["React"],"title":"无意间用了React Portals","uri":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/"},{"categories":["React"],"content":"什么是react portal portal(入口)能够允许我们将自己的组件挂到一个另一个时空的指定节点去,这个节点跟我们当前的DOM树没有半毛钱关系; ReactDOM.createPortal(child, container) 第一个参数即为自定义组件,第二个参数即为指定节点 ","date":"2019-09-28","objectID":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/:1:0","tags":["React"],"title":"无意间用了React Portals","uri":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/"},{"categories":["React"],"content":"portal出现的意义 如果在原有DOM树插入组件,影响DOM结构; 样式污染,组件所需数据流向混乱; ","date":"2019-09-28","objectID":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/:2:0","tags":["React"],"title":"无意间用了React Portals","uri":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/"},{"categories":["React"],"content":"示例 export default class YourComponent extends Component\u003cYourComponentProps,YourComponentState\u003e { private portalNode: HTMLDivElement; constructor(props: YourComponentProps) { super(props); const doc = window.document; this.portalNode = doc.createElement('div'); doc.body.appendChild(this.portalNode); } componentWillUnmount() { window.document.body.removeChild(this.portalNode); } render() { return createPortal( \u003cdiv\u003e // your code... \u003c/div\u003e, this.portalNode ) } } ","date":"2019-09-28","objectID":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/:3:0","tags":["React"],"title":"无意间用了React Portals","uri":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/"},{"categories":["React"],"content":"支持事件冒泡 虽然说portal传送的节点与原本的DOM树没关系,但是这个组件还是支持事件冒泡的,在原本的父节点上同样能够监听到组件的事件;具体示例可以直接看官网; react portals ","date":"2019-09-28","objectID":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/:4:0","tags":["React"],"title":"无意间用了React Portals","uri":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/"},{"categories":["React"],"content":"总结 portal因为能跳出原来DOM节点,一般为用在弹框和提示框这种独立性强的组件上; ","date":"2019-09-28","objectID":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/:5:0","tags":["React"],"title":"无意间用了React Portals","uri":"/%E6%97%A0%E6%84%8F%E9%97%B4%E7%94%A8%E4%BA%86react-portals/"},{"categories":["杂谈"],"content":" OAuth是一种行业标准的授权方式，我们在登录一些网站时，其也可以使用第三方账号比如QQ或者微信登录， 都是使用OAuth授权的， 版本有1.x和2.x两个，目前主要使用2.x版本，2.X版本大概有六种模式，本文介绍最常用的也是最安全的一种模式Authorization Code； OAuth2支持授权的几种方式（官网） ","date":"2019-08-08","objectID":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/:0:0","tags":["OAuth"],"title":"使用OAuth授权第三方网站","uri":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/"},{"categories":["杂谈"],"content":"六种模式 Authorization Code (先申请Code,再申请Token，较安全) Refresh Token （token过期后，避免重复登录，可以刷新Token） Device Code (一般用于TV等设备端，不常用) Password (需要再第三方网站暴露授权网站的密码，不安全) Implicit (不需要获取code,直接获取token,不推荐) Client （可以使用Client id和Client sercert 去授权网站获取客户端相关的信息，与第三方用户无关，不常用） ","date":"2019-08-08","objectID":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/:1:0","tags":["OAuth"],"title":"使用OAuth授权第三方网站","uri":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/"},{"categories":["杂谈"],"content":"获取Client Id和Client Secret 我们以Github为例，我们首先需要获取Client Id和Client Secret这两样东西，直接在Github个人设置里面develop settings选项，创建一个应用； ","date":"2019-08-08","objectID":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/:2:0","tags":["OAuth"],"title":"使用OAuth授权第三方网站","uri":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/"},{"categories":["杂谈"],"content":"如何请求Code OAuth请求官网示例 请求链接 GET https://github.com/login/oauth/authorize 请求参数 client_id（必填）：注册Github App时的client id； redirect_uri：请求成功后重定向的网址带有code； login: 登录特定账户； scope： 授权范围，比如scope=user; state: 随机字符串,防止跨站点请求伪造攻击; allow_signup: 默认为true,是否提供注册github选项； ","date":"2019-08-08","objectID":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/:3:0","tags":["OAuth"],"title":"使用OAuth授权第三方网站","uri":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/"},{"categories":["杂谈"],"content":"请求access_token 请求链接 POST https://github.com/login/oauth/access_token 请求参数 client_id（必填）：注册Github App时的client_id； client_secret（必填）：注册Github App时的client_secret； code（必填）：上一个请求返回的code; redirect_uri：同上； state：同上； code只能使用一次 ","date":"2019-08-08","objectID":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/:4:0","tags":["OAuth"],"title":"使用OAuth授权第三方网站","uri":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/"},{"categories":["杂谈"],"content":"访问用户信息 我们拿到了token就可以访问我们github上的信息了； 请求链接； GET https://api.github.com/user 在headers里面增加一个字段 Authorization: token 你的token ","date":"2019-08-08","objectID":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/:5:0","tags":["OAuth"],"title":"使用OAuth授权第三方网站","uri":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/"},{"categories":["杂谈"],"content":"postman请求返回示例 ","date":"2019-08-08","objectID":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/:6:0","tags":["OAuth"],"title":"使用OAuth授权第三方网站","uri":"/%E4%BD%BF%E7%94%A8oauth%E6%8E%88%E6%9D%83%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/"},{"categories":["React"],"content":" React Hook 是React16.8提出来的一个新特性，其意义就在于我们可以让函数组件变得跟类组件一样有能力管理自己的状态，这意味着我们以后写的所有组件都可以是Function，对于初学者来说降低了学习成本（压根不用管this是个啥），而且我们可以自定义hook，能够提高状态逻辑的复用，从而也便于维护。 ","date":"2019-08-02","objectID":"/react-hooks%E5%AE%9E%E8%B7%B5/:0:0","tags":["react"],"title":"React Hooks实践","uri":"/react-hooks%E5%AE%9E%E8%B7%B5/"},{"categories":["React"],"content":"State Hooks ","date":"2019-08-02","objectID":"/react-hooks%E5%AE%9E%E8%B7%B5/:1:0","tags":["react"],"title":"React Hooks实践","uri":"/react-hooks%E5%AE%9E%E8%B7%B5/"},{"categories":["React"],"content":"useState react为我们提供了useState这个函数，使用此函数就可以取代我们之前的每个组件的状态管理了； import { useState } from 'react' function count() { // useState函数为我们解构了一个变量num和一个setNum函数，并且将变量初始值赋值为“0” const [num, setNum] = useState(\"0\"); // 我们在这里读取num的值， 并且每点击一次按钮都会使num+1 return \u003cbutton onClick={() =\u003e {setNum(num + 1)}}\u003e{num}\u003c/button\u003e } 当我们每次改变num的值时，就会重新执行count函数，不过不用担心，num的初始化只会执行一次; ","date":"2019-08-02","objectID":"/react-hooks%E5%AE%9E%E8%B7%B5/:1:1","tags":["react"],"title":"React Hooks实践","uri":"/react-hooks%E5%AE%9E%E8%B7%B5/"},{"categories":["React"],"content":"useReducer 其实useState也是基于useReducer的，用过redux的人对reducer不陌生，reducer是一个纯函数，会根据action中type的不同返回改变后新的状态; import { useReducer } from 'react' // 创建一个reducer function myReducer(state, action){ switch(action.type) { case \"add\": return state + 1 case \"minus\": return state -1 default: return state } } // 函数组件 function count() { // 传入reducer和初始值 const [num, dispatchNum] = useReducer(myReducer, \"0\"); return \u003cbutton onClick={() =\u003e {dispatchNum({type: \"add\"})}}\u003e{num}\u003c/button\u003e } ","date":"2019-08-02","objectID":"/react-hooks%E5%AE%9E%E8%B7%B5/:1:2","tags":["react"],"title":"React Hooks实践","uri":"/react-hooks%E5%AE%9E%E8%B7%B5/"},{"categories":["React"],"content":"Effect Hook Effect Hook可以看作是代替了一些生命周期函数 import { useState, useEffect } from 'react' function count() { const [num, setNum] = useState(\"0\"); useEffect(() =\u003e { const interval = setInterval(() =\u003e { setNum(num + 1) }, 1000) // 最后要return一下，记得清除定时器 return () =\u003e clearInterval(interval) }, [num]) return \u003cbutton onClick={() =\u003e {setNum(num + 1)}}\u003e{num}\u003c/button\u003e } useEffect函数中第一个参数为组件第一次渲染时执行的函数（最后return的是定时器卸载的函数，可以看作是componentWillUnMount生命周期内做的事），第二参数表示依赖的值，只有依赖的值变化时，useEffect才会重新执行； ","date":"2019-08-02","objectID":"/react-hooks%E5%AE%9E%E8%B7%B5/:2:0","tags":["react"],"title":"React Hooks实践","uri":"/react-hooks%E5%AE%9E%E8%B7%B5/"},{"categories":["React"],"content":"Context Hook 顾名思义这是一个上下文hook // 新建一个context文件myContext.js import React from 'react' export default React.createContext(\"\") // 在另一个文件中引入 import MyContext from './myContext' // 通过MyContext.Provider 传值 \u003cMyContext.Provider value=\"test\"\u003e \u003cComponent/\u003e \u003c/MyContext.Provider\u003e // 在组件中使用 import {useContext} from 'react' import MyContext from './myContext' function test() { const contextValue = useContext(MyContext) return \u003cdiv\u003e{contextValue}\u003c/div\u003e } ","date":"2019-08-02","objectID":"/react-hooks%E5%AE%9E%E8%B7%B5/:3:0","tags":["react"],"title":"React Hooks实践","uri":"/react-hooks%E5%AE%9E%E8%B7%B5/"},{"categories":["React"],"content":"Ref Hook import {useRef} from 'react' function testRef() { const inputRef = useRef() useEffect(() =\u003e { console.log(inputRef) }) return \u003cinput ref={inputRef}\u003e测试ref\u003c/input\u003e } ","date":"2019-08-02","objectID":"/react-hooks%E5%AE%9E%E8%B7%B5/:4:0","tags":["react"],"title":"React Hooks实践","uri":"/react-hooks%E5%AE%9E%E8%B7%B5/"},{"categories":["React"],"content":"自定义Hook hook其实就是一个函数，在这个函数里我们也可以使用其它hook,自定义的hook要以use开头,下面是官网上的例子，已经很好了； import React, { useState, useEffect } from 'react'; function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() =\u003e { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =\u003e { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } ","date":"2019-08-02","objectID":"/react-hooks%E5%AE%9E%E8%B7%B5/:5:0","tags":["react"],"title":"React Hooks实践","uri":"/react-hooks%E5%AE%9E%E8%B7%B5/"},{"categories":["Java"],"content":" xml文件一般有三种用途，1. 可以用来保存数据，2. 可以用来做配置文件，3. 数据传输载体，本篇文章主要记载java中如何解析XML文件。 ","date":"2019-07-24","objectID":"/java%E4%B8%AD%E8%A7%A3%E6%9E%90xml/:0:0","tags":["Java"],"title":"java中解析XML","uri":"/java%E4%B8%AD%E8%A7%A3%E6%9E%90xml/"},{"categories":["Java"],"content":"XML解析方式 XML文件的定义以及标签的用法就不多说了，XML文件的约束主要有两种（DTD和Schema），现在最常见的XML的解析方式主要有两种，一个是DOM， 一个是SAX;两者区别如下 DOM方法是将XML文件读取到内存中去生成树状结构（对象），这样的话如果文件过大就可能会出现内存溢出； SAX（simple api for xml）方法则是事件驱动模式，读取一行解析一行； 针对这两种解析方式，市场上出现了很多的解决方案比如dom4j,jaxp,jdom等 ","date":"2019-07-24","objectID":"/java%E4%B8%AD%E8%A7%A3%E6%9E%90xml/:1:0","tags":["Java"],"title":"java中解析XML","uri":"/java%E4%B8%AD%E8%A7%A3%E6%9E%90xml/"},{"categories":["Java"],"content":"Dom4j使用 首先需要用到Dom4j的jar包； try { //1. 创建sax读取对象 SAXReader reader = new SAXReader(); //jdbc -- classloader //2. 指定解析的xml源 Document document = reader.read(new File(\"src/xml/stus.xml\")); //3. 得到元素、 //得到根元素 Element rootElement= document.getRootElement(); //获取根元素下面的子元素 age //rootElement.element(\"age\") //System.out.println(rootElement.element(\"stu\").element(\"age\").getText()); //获取根元素下面的所有子元素 。 stu元素 List\u003cElement\u003e elements = rootElement.elements(); //遍历所有的stu元素 for (Element element : elements) { //获取stu元素下面的name元素 String name = element.element(\"name\").getText(); String age = element.element(\"age\").getText(); String address = element.element(\"address\").getText(); System.out.println(\"name=\"+name+\"==age+\"+age+\"==address=\"+address); } } catch (Exception e) { e.printStackTrace(); } 如果XML层级过深，我们可以使用Dom4j中的Xpath,xpath其实是xml的路径语言，支持我们在解析xml的时候，能够快速的定位到具体的某一个元素,当然我们还是需要添加jar包； Element nameElement = (Element) rootElement.selectSingleNode(\"//name\"); System.out.println(nameElement.getText()); System.out.println(\"----------------\"); //获取文档里面的所有name元素 List\u003cElement\u003e list = rootElement.selectNodes(\"//name\"); for (Element element : list) { System.out.println(element.getText()); } ","date":"2019-07-24","objectID":"/java%E4%B8%AD%E8%A7%A3%E6%9E%90xml/:2:0","tags":["Java"],"title":"java中解析XML","uri":"/java%E4%B8%AD%E8%A7%A3%E6%9E%90xml/"},{"categories":["数据库"],"content":" JDBC全称为JAVA Database Connectivity (java数据库连接),是SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且java语言使用比较广泛，sun公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的java程序只要使用sun公司提供的jdbc驱动即可。 ","date":"2019-07-22","objectID":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/:0:0","tags":["数据库"],"title":"使用JDBC对Mysql数据库的CRUD操作","uri":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"JDBC驱动 首先我们需要去下载对应数据库的JDBC驱动，MySQL就是下载MySQL的JDBC驱动，Oracle就下载Oracle的JDBC驱动 ","date":"2019-07-22","objectID":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/:1:0","tags":["数据库"],"title":"使用JDBC对Mysql数据库的CRUD操作","uri":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"新建数据库配置文件xxx.properties 在项目根目录下新建xxx.properties文件，这里的信息以key=value的形式书写，我们在连接数据库时就会从这里面读取配置信息； driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost/student name=root password=root ","date":"2019-07-22","objectID":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/:2:0","tags":["数据库"],"title":"使用JDBC对Mysql数据库的CRUD操作","uri":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"新建工具包，抽离出数据库连接语句 我们新建一个工具包比如com.chenxiaolani.util,在这下面我们新建一个JDBCUtil.java的文件，内容主要是使用JDBC抽离出数据库连接语句，还有一些释放资源的语句，以便复用； package com.chenxiaolani.uitl; import java.io.FileInputStream; import java.io.InputStream; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; public class JDBCUtil { static String driverClass = null; static String url = null; static String name = null; static String password= null; static{ try { //1. 创建一个属性配置对象 Properties properties = new Properties(); //2. 读取数据库连接配置文件 InputStream is = new FileInputStream(\"jdbc.properties\"); //3. 导入输入流。 properties.load(is); //4. 读取属性 driverClass = properties.getProperty(\"driverClass\"); url = properties.getProperty(\"url\"); name = properties.getProperty(\"name\"); password = properties.getProperty(\"password\"); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接对象 * @return */ public static Connection getConn(){ Connection conn = null; try { //1. 这个其实不用写，JDBC源码中已经帮我们注册了一次 Class.forName(driverClass); //2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。 conn = DriverManager.getConnection(url, name, password); } catch (Exception e) { e.printStackTrace(); } return conn; } /** * 释放资源 * @param conn * @param st * @param rs */ public static void release(Connection conn , Statement st , ResultSet rs){ closeRs(rs); closeSt(st); closeConn(conn); } public static void release(Connection conn , Statement st){ closeSt(st); closeConn(conn); } private static void closeRs(ResultSet rs){ try { if(rs != null){ rs.close(); } } catch (SQLException e) { e.printStackTrace(); }finally{ rs = null; } } private static void closeSt(Statement st){ try { if(st != null){ st.close(); } } catch (SQLException e) { e.printStackTrace(); }finally{ st = null; } } private static void closeConn(Connection conn){ try { if(conn != null){ conn.close(); } } catch (SQLException e) { e.printStackTrace(); }finally{ conn = null; } } } ","date":"2019-07-22","objectID":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/:3:0","tags":["数据库"],"title":"使用JDBC对Mysql数据库的CRUD操作","uri":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"DAO模式 DAO即为（Data Access Object），中文为数据访问对象，DAO模式一般为两个文件，一个是定义方法的接口，一个则是实现这些接口的文件； 首先我们新建一个包比如cpm.chenxiaolani.dao, 然后再新建一个dao文件，一般来说一个表就是一个dao文件，比如针对User表新建UserDao.java文件； package com.chenxiaolani.dao; /** * 定义操作数据库的方法 */ public interface UserDao { /** * 查询所有 */ void findAll(); /** * 根据id去更新具体的用户名 * @param id * @param name */ void update(int id , String name); /** * 删除 */ void delete(int id); /** * 执行添加 * @param userName * @param password */ void insert(String userName , String password); } 我们再新建一个包com.chenxiaolani.dao.impl，此包下的文件来实现接口中的方法，对数据库直接操作 package com.chenxiaolani.dao.impl; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import com.chenxiaolani.dao.UserDao; import com.chenxiaolani.uitl.JDBCUtil; public class UserDaoImpl implements UserDao{ @Override public void findAll() { Connection conn = null; Statement st = null; ResultSet rs = null; try { //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql = \"select * from t_user\"; rs = st.executeQuery(sql); while(rs.next()){ String userName = rs.getString(\"username\"); String password = rs.getString(\"password\"); System.out.println(userName+\"=\"+password); } } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, st, rs); } } @Override public void insert(String userName, String password) { Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtil.getConn(); String sql = \"insert into t_user values(null , ? , ?)\"; ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个 ps.setString(1, userName); ps.setString(2, password); int result = ps.executeUpdate(); if(result\u003e0){ System.out.println(\"添加成功\"); }else{ System.out.println(\"添加失败\"); } } catch (SQLException e) { e.printStackTrace(); }finally{ JDBCUtil.release(conn, ps); } } @Override public void delete(int id) { Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtil.getConn(); String sql = \"delete from t_user where id = ?\"; ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个 ps.setInt(1, id); int result = ps.executeUpdate(); if(result\u003e0){ System.out.println(\"删除成功\"); }else{ System.out.println(\"删除失败\"); } } catch (SQLException e) { e.printStackTrace(); }finally{ JDBCUtil.release(conn, ps); } } @Override public void update(int id, String name) { Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtil.getConn(); String sql = \"update t_user set username=? where id =?\"; ps = conn.prepareStatement(sql); ps.setString(1, name); ps.setInt(2, id); int result = ps.executeUpdate(); if(result\u003e0){ System.out.println(\"更新成功\"); }else{ System.out.println(\"更新失败\"); } } catch (SQLException e) { e.printStackTrace(); }finally{ JDBCUtil.release(conn, ps); } } } ","date":"2019-07-22","objectID":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/:4:0","tags":["数据库"],"title":"使用JDBC对Mysql数据库的CRUD操作","uri":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"单元测试 首先需要添加junit,eclipse已经内置了，右键build path 中add libraries即可 然后我们就可以新建一个测试包专门管理我们写的测试文件比如com.chenxiaolani.test package com.chenxiaolani.test; import org.junit.Test; import com.chenxiaolani.dao.UserDao; import com.chenxiaolani.dao.impl.UserDaoImpl; public class TestUserDaoImpl { @Test public void testInsert(){ UserDao dao = new UserDaoImpl(); dao.insert(\"aobama\", \"911\"); } @Test public void testUpdate(){ UserDao dao = new UserDaoImpl(); dao.update(2, \"chenxiaolani\"); } @Test public void testDelete(){ UserDao dao = new UserDaoImpl(); dao.delete(30); } @Test public void testFindAll(){ UserDao dao = new UserDaoImpl(); dao.findAll(); } } ","date":"2019-07-22","objectID":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/:5:0","tags":["数据库"],"title":"使用JDBC对Mysql数据库的CRUD操作","uri":"/%E4%BD%BF%E7%94%A8jdbc%E5%AF%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84crud%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":" 数据库分为关系型数据库和非关系型数据库，作为前端，对于mongodb再熟悉不过了，mongodb就是非关系型数据库，除此之外还有常见的还有redis，这种数据库的特点就是以Key,value的形式存储的，关系型数据库就很多了，mysql,oracle,db2等，本片文章主要记录我在学习MySQL关于CRUD的命令行操作。 ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:0:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"登录数据库 -u为用户名， -p为密码，我都设为root； // 注意-p后面不要有空格 mysql -uroot -proot ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:1:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"创建数据库 create database 数据库的名字; create database 数据库的名字 character set 字符集编码; create database 数据库的名字 character set 字符集编码 collate 比较规则; 注意要加分号 create database student; create database student character set utf8; create database student character set utf8 collate utf8_general_ci; ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:2:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"查看数据库 默认的数据库不要动它 show databases; show create database student; // 查看student数据库的定义语句 ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:3:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"修改数据库 使用alter alter database student character set gbk; ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:4:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"删除数据库 使用drop drop database student; ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:5:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"其他数据库操作 use student; // 切换到student数据库 select database(); // 查看当前数据库 ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:6:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"表的创建 create table 表名( 列名 列的类型 约束, ); create table employee (id int primary key auto_increment, name varchar(20) not null, birthday date, job varchar(30), salary double, ); ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:7:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"查看表 show tables; // 查看数据库内的所有表 show create table employee; // 查看employee的建表语句 desc employee; // 查看employee的表结构 ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:8:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"修改表 添加列（add），修改列（modify）,修改列名(cahnge)，删除列(drop), 修改表明（rename）,修改表的字符集（character set） // 添加 alter table student add address int not null; // 修改 alter table student modify address varchar(2); // 修改列名 alter table student change address gender varchar(2); // 删除 alter table student drop address; // 改表名 rename table student to student2; // 修改表的字符集 alter table student character set gbk; ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:9:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"删除表 drop table student; ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:10:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"表数据插入 insert into 表名(列名1,列名2)values(值1,值2); insert into 表名 values(值1,值2); // 上面的简单写法 insert into 表名values(值1,值2),(值1,值2),(值1,值2);// 批量插入 ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:11:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"表数据删除 delete from 表名 [where 条件] truncate table 表名: 先删除表,再重建表 delete与truncate的区别 delete是将数据一条一条的删除，在数据量比较少的情况下效率高； truncate是先删除表,再重建表，由于更改了表结构，数据量大的情况下推荐； ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:12:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"表数据更新 update 表名 set 列名=值, 列名=值 [where 条件] ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:13:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"表数据查询 通用格式: select [distinct（去重）] [*] [列名1,列名2] from 表名 where 条件 group by ..having 条件过滤 order by 排序 如果插入数据乱码，需要去mysql中的配置文件中my.ini57行将编码改为gbk ","date":"2019-07-13","objectID":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/:14:0","tags":["数据库"],"title":"MYSQL的CRUD操作之命令行","uri":"/mysql%E7%9A%84crud%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"categories":["react"],"content":" 在之前的项目中遇到一个需求，需要支持将antd design 中表格数据（多表头）导出到excel,看了网上的例子很少，这里就记录一下。 主要用到了better-xlsx和file-saver两个库 import { File } from 'better-xlsx'; import { saveAs } from 'file-saver'; function ExportExcel(column, dataSource, fileName = 'example') { // 新建工作谱 const file = new File(); // 新建表 let sheet = file.addSheet('sheet-test'); // 获取表头行数 let depth = getDepth(column); // 获取表头的列数 let columnNum = getColumns(column); // 新建表头行数 let rowArr = []; for (let k = 0; k \u003c depth; k++) { rowArr.push(sheet.addRow()); } // 根据列数填充单元格 rowArr.map(ele =\u003e { for (let j = 0; j \u003c columnNum; j++) { let cell = ele.addCell(); cell.value = j; } }); // 初始化表头 init(column, 0, 0); // 按顺序展平column let columnLineArr = []; columnLine(column); // 根据column,将dataSource里面的数据排序，并且转化为二维数组 let dataSourceArr = []; dataSource.map(ele =\u003e { let dataTemp = []; columnLineArr.map(item =\u003e { dataTemp.push({ [item.dataIndex]: ele[item.dataIndex], value: ele[item.dataIndex], }); }); dataSourceArr.push(dataTemp); }); // debugger; // 绘画表格数据 dataSourceArr.forEach((item, index) =\u003e { //根据数据,创建对应个数的行 let row = sheet.addRow(); row.setHeightCM(0.8); //创建对应个数的单元格 item.map(ele =\u003e { let cell = row.addCell(); if (ele.hasOwnProperty('num')) { cell.value = index + 1; } else { cell.value = ele.value; } cell.style.align.v = 'center'; cell.style.align.h = 'center'; }); }); //设置每列的宽度 for (var i = 0; i \u003c 4; i++) { sheet.col(i).width = 20; } file.saveAs('blob').then(function(content) { saveAs(content, fileName + '.xlsx'); }); // 按顺序展平column function columnLine(column) { column.map(ele =\u003e { if (ele.children === undefined || ele.children.length === 0) { columnLineArr.push(ele); } else { columnLine(ele.children); } }); } // 初始化表头 function init(column, rowIndex, columnIndex) { column.map((item, index) =\u003e { let hCell = sheet.cell(rowIndex, columnIndex); // 如果没有子元素, 撑满列 if (item.title === '操作') { hCell.value = ''; return; } else if (item.children === undefined || item.children.length === 0) { // 第一行加一个单元格 hCell.value = item.title; hCell.vMerge = depth - rowIndex - 1; hCell.style.align.h = 'center'; hCell.style.align.v = 'center'; columnIndex++; // rowIndex++ } else { let childrenNum = 0; function getColumns(arr) { arr.map(ele =\u003e { if (ele.children) { getColumns(ele.children); } else { childrenNum++; } }); } getColumns(item.children); hCell.hMerge = childrenNum - 1; hCell.value = item.title; hCell.style.align.h = 'center'; hCell.style.align.v = 'center'; let rowCopy = rowIndex; rowCopy++; init(item.children, rowCopy, columnIndex); // 下次单元格起点 columnIndex = columnIndex + childrenNum; } }); } // 获取表头rows function getDepth(arr) { const eleDepths = []; arr.forEach(ele =\u003e { let depth = 0; if (Array.isArray(ele.children)) { depth = getDepth(ele.children); } eleDepths.push(depth); }); return 1 + max(eleDepths); } function max(arr) { return arr.reduce((accu, curr) =\u003e { if (curr \u003e accu) return curr; return accu; }); } // 计算表头列数 function getColumns(arr) { let columnNum = 0; arr.map(ele =\u003e { if (ele.children) { getColumns(ele.children); } else { columnNum++; } }); return columnNum; } } export default ExportExcel; 引入文件，只要传入表头字段和表格数据即可。 ","date":"2019-07-02","objectID":"/antd-design-%E4%B8%AD%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E4%B8%BAexcel-%E6%94%AF%E6%8C%81%E5%A4%9A%E8%A1%A8%E5%A4%B4/:0:0","tags":["react"],"title":"antd design 中表格数据导出为excel(支持多表头)","uri":"/antd-design-%E4%B8%AD%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E4%B8%BAexcel-%E6%94%AF%E6%8C%81%E5%A4%9A%E8%A1%A8%E5%A4%B4/"},{"categories":["JavaScript"],"content":" 一直在用promise，也想过自己能不能也实现一个简单的promise，但是一直没有时间；这不最近辞职了，时间就多起来了。当然也参考了网上很多人的实现方法。 本篇文章主要参考自https://github.com/ElemeFE/node-practice/blob/master/control/promise/README.md promise的意义就是能够很好的控制异步流程，避免回调地狱；首先来看一下promise的基本用法 ","date":"2019-01-06","objectID":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/:0:0","tags":["promise"],"title":"手动实现一个简单的promise","uri":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/"},{"categories":["JavaScript"],"content":"基本实现效果 let p = new Promisee((resolve, reject) =\u003e { setTimeout(() =\u003e { resolve('hello') }, 0) }) p.then((val) =\u003e { console.log(val) return 'world' }) .then((val) =\u003e { console.log(val) }) ","date":"2019-01-06","objectID":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/:1:0","tags":["promise"],"title":"手动实现一个简单的promise","uri":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/"},{"categories":["JavaScript"],"content":"基本书写 当我们想封装一个函数时，我们只关心两个东西，它需要输入什么以及它要输出什么。 输入一个函数接受两个回调参数 输出一个对象，里面为then函数，函数参数为成功回调和失败回调 function Promisee(fn) { function resolve() { } function reject() { } fn(resolve, reject) // 返回一个对象 return { then: function(onResolve, onReject) { } } } ","date":"2019-01-06","objectID":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/:2:0","tags":["promise"],"title":"手动实现一个简单的promise","uri":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/"},{"categories":["JavaScript"],"content":"加入状态模式 promise内部使用了状态模式，根据不同的状态执行不同的逻辑 // 状态唯一 const FULFILLED = Symbol(); const REJECTED = Symbol(); const PEDING = Symbol(); function Promisee(fn) { // 传入的必须是函数 if (typeof fn !== \"function\") { throw new Error('param should be a function!') } let state = PEDING let value = null function resolve(result) { // 修改状态 state = FULFILLED value = result } function reject(errror) { state = REJECTED value = errror } fn(resolve, reject) // 返回一个对象 return { then: function(onResolve, onReject) { switch(state) { // 成功 case FULFILLED: onResolve(value) break // 失败 case REJECTED: onReject(value) break } } } } ","date":"2019-01-06","objectID":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/:3:0","tags":["promise"],"title":"手动实现一个简单的promise","uri":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/"},{"categories":["JavaScript"],"content":"兼容异步 如果代码是异步，根据promise/a+规范，此时状态为peding,所以在peding状态下，我们需要将异步执行的回调函数先存放起来，等到状态变为FULFILLED，或者REJECTED时，再执行。 // 状态唯一 const FULFILLED = Symbol(); const REJECTED = Symbol(); const PEDING = Symbol(); function Promisee(fn) { // 传入的必须是函数 if (typeof fn !== \"function\") { throw new Error('param should be a function!') } let state = PEDING let value = null let handler = [] function resolve(result) { // 修改状态 state = FULFILLED value = result handler.forEach(next) handler = null } function reject(errror) { state = REJECTED value = errror handler.forEach(next) handler = null } fn(resolve, reject) // 分离 function next({onResolve, onReject}) { switch(state) { // 成功 case FULFILLED: onResolve \u0026\u0026 onResolve(value) break // 失败 case REJECTED: onReject \u0026\u0026 onReject(value) break // 异步 case PEDING: handler.push({ onResolve, onReject }) } } // 返回一个对象 return { then: function(onResolve, onReject) { next({onResolve, onReject}) } } } ","date":"2019-01-06","objectID":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/:4:0","tags":["promise"],"title":"手动实现一个简单的promise","uri":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/"},{"categories":["JavaScript"],"content":"then链式调用 then的链式调用需要我们再返回一个promise // 状态唯一 const FULFILLED = Symbol(); const REJECTED = Symbol(); const PEDING = Symbol(); function Promisee(fn) { // 传入的必须是函数 if (typeof fn !== \"function\") { throw new Error('param should be a function!') } let state = PEDING let value = null let handler = [] function resolve(result) { // 修改状态 state = FULFILLED value = result handler.forEach(next) handler = null } function reject(errror) { state = REJECTED value = errror handler.forEach(next) handler = null } fn(resolve, reject) // 分离 function next({onResolve, onReject}) { switch(state) { // 成功 case FULFILLED: onResolve \u0026\u0026 onResolve(value) break // 失败 case REJECTED: onReject \u0026\u0026 onReject(value) break // 异步 case PEDING: handler.push({ onResolve, onReject }) } } // 返回一个对象 return { then: function(onResolve, onReject) { // 链式调用 return new Promisee((resolve, reject) =\u003e { next({ onResolve: (val) =\u003e { // 先调用上一层promise,再调用下一层并且沿用上一层返回的参数 resolve(onResolve(value)) }, onReject: (err) =\u003e { reject(onReject(value)) } }) }) } } } ","date":"2019-01-06","objectID":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/:5:0","tags":["promise"],"title":"手动实现一个简单的promise","uri":"/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/"},{"categories":["JavaScript"],"content":" 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。总结两点，第一顺序访问一个集合，第二使用者无需知道集合的内部（封装）。 ","date":"2019-01-06","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/:0:0","tags":["js设计模式"],"title":"js设计模式之迭代器模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"迭代器演示 class Iterator { constructor(container) { this.list = container.list this.index = 0 } next() { if(this.hasNext()) { return this.list[this.index++] } return null } hasNext() { if(this.index \u003e= this.list.length) { return false } return true } } class Container { constructor(list) { this.list = list } // 生成遍历器 getIterator() { return new Iterator(this) } } // 测试 let arr = [1,2,3,4,5] let container = new Container(arr) // 生成遍历器 let iterator = container.getIterator() while(iterator.hasNext()) { console.log(iterator.next()) } ","date":"2019-01-06","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/:0:1","tags":["js设计模式"],"title":"js设计模式之迭代器模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"es6中的迭代器 js中已经有很多的函数默认内置迭代器 Set, forEach,这些数据类型都有[Symbol.iterator]这个属性可以通过Array.prototype[Symbol.iterator]来测试 以下为es6的iterator示例 // 自己封装迭代器函数 function each(data) { // 生成的这个对象就有next方法 let iterator = data[Symbol.iterator]() // 手动next console.log(iteator.next()) // {value: 1, done: false} console.log(iteator.next()) // {value: undefined, done: true} let item = {done: false} while(!item.done) { item = iterator.next() if(!item.done) { console.log(item.value) } } } es6不需要每次都要书写以上函数，它提供了一种新语法for…of… for…of…能够遍历带有遍历器特性的数组即它有[Symbol.iterator]这个属性 ","date":"2019-01-06","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/:0:2","tags":["js设计模式"],"title":"js设计模式之迭代器模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"Generator Generator函数返回的对象中也有[Symbol.iterator]这个属性，说明它也实现迭代器的接口，不过现在应该也不怎么用了。 ","date":"2019-01-06","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/:0:3","tags":["js设计模式"],"title":"js设计模式之迭代器模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":" 状态模式往往会带来代码量的增加，但是它也许是解决某些需求场景的最好方法，状态模式的关键是区分事物内部的状态，事物内部的状态往往会带来事物行为的改变。 ","date":"2019-01-02","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:0:0","tags":["js设计模式"],"title":"js设计模式之状态模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"if/else/switch的情况 实际开发中，我们可能会遇到使用大量if/else/switch的情况，根据不同的状态，通过判断执行不同状态对应的逻辑操作，比如如下 //执行动作 function doAction(state){ //state0 if(state === '0'){ console.log('执行0'); } //state1 if(state === '1'){ console.log('执行1'); } //state2 if(state === '2'){ console.log('执行2'); } } 状态变多即使用switch也会越来越繁琐，这时候就可以使用状态模式了。 ","date":"2019-01-02","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:0:1","tags":["js设计模式"],"title":"js设计模式之状态模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"状态模式改善 状态模式，就是将每一种条件作为对象内部的一种状态，面对不同的判断结果，我们只需选择不同的状态便可. var ResultState = function(){ //各种情况的业务逻辑保存在内部状态中 var states = { state1:function(){ console.log('情况一的业务逻辑'); }, state2:function(){ console.log('情况二的业务逻辑'); }, state3:function(){ console.log('情况三的业务逻辑'); } } //获取某一状态的对应逻辑并执行 function show(state){ states[state] \u0026\u0026 states[state](); } return { doActionByState: show } }(); // 传入状态，即会执行状态所对应的业务逻辑。 ResultState.doActionByState('state1'); ","date":"2019-01-02","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:0:2","tags":["js设计模式"],"title":"js设计模式之状态模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"promise es6中的promise内部就是一个状态机。 ","date":"2019-01-02","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:0:3","tags":["js设计模式"],"title":"js设计模式之状态模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":" 装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加指责，总结来说就是两点，第一为对象添加新功能，第二不改变原有的结构和功能。 ","date":"2018-12-24","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:0","tags":["js设计模式"],"title":"js设计模式之装饰者模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"装饰函数 在javascript中，万物皆对象，函数则是一等对象，当我们想要为函数添加一些功能时，如果直接改写函数，就违背了开放-封闭原则，我们可以保留原有函数的引用，然后直接放到新函数内执行，比如 let frank = function() { console.log(\"i am frank\") } // 我们想为frank添加一个技能时，先用临时变量把原有函数存起来 let oldFrank = frank // 放到新的frank函数执行 frank = function() { oldFrank() console.log(\"i am best\") } 此做法符合开放-封闭原则，在不改变原函数源代码的情况下为其添加新功能，但是每次添加一个新功能都必须维护一个中间变量（比如oldFrank）,长此以往，要维护的中间变量就会越来越多。 ","date":"2018-12-24","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:1","tags":["js设计模式"],"title":"js设计模式之装饰者模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"用AOP装饰函数 AOP就是面向切面编程,把一些与核心业务逻辑无关的功能抽离出来 再通过“动态织入”方式掺入业务逻辑模块 在这里我们需要两个方法，一个是前置装饰，一个是后置装饰 Function.prototype.before = function(beforeFunc){ var that = this; return function(){ beforeFunc.apply(this, arguments); return that.apply(this, arguments); } } Function.prototype.after = function(afterFunc){ var that = this; return function(){ var ret = that.apply(this, arguments); afterFunc.apply(this, arguments); return ret; } } 为了避免污染原型，我们可以改写before和after方法如下 var before = function(fn, beforefn) { return function() { beforefn.apply(this, arguments) return fn.apply(this, arguments) } } var after = function(fn, afterfn){ return function(){ var ret = fn.apply(this, arguments); afterfn.apply(this, arguments); return ret; } } 以前置装饰为例，先执行新传入的函数，此函数就是新添加的功能，然后再执行原函数，后置装饰同理，这样我们就能在保证原函数不动的情况下，动态的为原函数添加功能。 AOP动态的添加函数参数 var func = function(param) { console.log(param) } func = func.before(function(param) { param.b = 'b' }) func({a: 'a'}) // 输出{a: 'a', b: 'b'} ","date":"2018-12-24","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:2","tags":["js设计模式"],"title":"js设计模式之装饰者模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"es7装饰器 装饰类 // 1. 装饰器 装饰类 @testDec class Demo { } // 装饰器是一个函数 function testDec(target) { target.isDec = true } alert(Demo.isDec) // 原理 @decorator class A {} // 等同于 class A {} A = decorator(A) || A 可以传参 // 可以传参, 需要返回一个函数 function mixins(...list) { return function(target) { Object.assign(target.prototype, ...list) } } const Foo = { foo() { alert(\"foo\") } } @mixins(Foo) class MyClass { } let obj = new MyClass() // MyClass是没有foo函数的， 通过装饰器添加 obj.foo() 装饰方法 class Person { constructor() { this.first = 'A' this.last = 'B' } // 装饰这个方法，变成可读 @readonly name() { return `${this.first}${this.last}` } } // name 方法名字 descriptor方法值 function readonly(target, name, descriptor) { descriptor.writable = false return descriptor } ","date":"2018-12-24","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:3","tags":["js设计模式"],"title":"js设计模式之装饰者模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"使用第三方库 core-decorators // 只读 import { readonly } from 'core-decorators' class Person { @readonly name() { return '11' } } // 废弃 import { deprecate } from 'core-decorators' class Person { // 如果这个方法即将废弃，可以使用这个装饰器提醒开发者 @deprecate(\"即将弃用\") facepalm(){ ... } } ","date":"2018-12-24","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:4","tags":["js设计模式"],"title":"js设计模式之装饰者模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":" 适配器模式是一种简单设计模式，主要是用来解决老接口不兼容的问题，对于不兼容的老接口，我们没必要重写，只需创建一个适配器即可。 ","date":"2018-12-17","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:0:0","tags":["js设计模式"],"title":"js设计模式之适配器模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"获取城市接口例子 现在我们有一个接口用来获取广东省所有的城市，如下 // 模拟接口，返回广东城市数据 let getGuanDongCity = function() { let guanDongCity = [ { name: 'shenzhen', id: 11 }, { name: 'guangzhou', id: 12 } ] return guanDongCity } // 定义渲染函数 let render = function(fn) { document.write(JSON.stringify(fn())) } // 渲染 render(getGuanDongCity) 然后我们发现这个接口显示的城市并不齐全，我们又找到了另外一个齐全的接口作为补充，这个接口返回的数据格式和原来返回的数据格式不一样，这时候我们要改写原来的接口吗，nono,我们只要为原来的接口包装一个适配函数即可。 // 新的补充接口的数据格式 let guanDongCity = { shenzhen: 11, guangzhou: 12, zhuhai: 13 } 为原来接口编写适配函数 let addressAdapter = function( oldAddressfn ) { let address = {} let oldAddress = oldAddressfn() oldAddress.map((ele) =\u003e { address[ele.name] = ele.id }) return function(){ return address } } // 这样渲染的数据格式就一样了 render(addressAdapter(getGuanDongCity)) ","date":"2018-12-17","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:0:1","tags":["js设计模式"],"title":"js设计模式之适配器模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"那些似曾相识的场景 jquery的封装 // 一个项目之前封装了一个ajax方法如下 ajax({ url: '/getData', type: 'post', data: { id: 1 } }) // 现在我们需要这么调用ajax $.ajax({ url: '/getData', type: 'post', data: { id: 1 } }) 我们不可能修改每一处调用ajax的地方,我们可以在封装ajax的地方做一层适配器如下 var $ = { ajax:function(options) { return ajax(options) } } 仔细想想，其实这种模式我们每天都在用，当后台返回的数据结构不满足前端页面所需要的结构时，而后台接口又很难改时，我们只要需要编写一个适配函数即可。（这不就是我每天经常干的嘛） ","date":"2018-12-17","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:0:2","tags":["js设计模式"],"title":"js设计模式之适配器模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":" 代理模式的定义：为一个对象提供代用品或占位符，以便控制对它的访问；注意使用者无权访问目标对象的。 最常见的就是科学上网了 代理模式根据其目的，也有好多种代理 保护代理（代理掉不必要的请求） 虚拟代理 （创建开销很大的对象时，可以先用一个小对象代替，等到真正使用时再创建） 缓存代理 （为一些开销大的运算提供暂时的存储，如果下次传的参数一致时，可以返回这个结果） 其他代理（在js中适用性不高） ","date":"2018-12-05","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:0:0","tags":["js设计模式"],"title":"js设计模式之代理模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"保护代理 // 这个类外面是无权访问的 class ReadImg { constructor(fileName) { this.fileName = fileName this.loadFormDIsk() // 加载，模拟 } loadFormDIsk() { console.log('loading...' + this.fileName) } display() { console.log('display...' + this.fileName) } } // 定义代理函数 class ProxyImg { constructor(fileName) { this.realImg = new ReadImg(fileName) } display() { this.realImg.display() } } let proxyImg = new ProxyImg('1.png') e6中的proxy 明星经纪人案例 let start = { name: 'steven', age: 24, phone: '12334445' } // 经纪人来代理 let agent = new Proxy(start, { get: function(target, key) { if(key === 'phone') { // 给经纪人自己的号码 return '111121111' } if(key === 'price') { // 经纪人来报价 return 1232333 } return target[key] }, set: function(target, key, val) { if(key === 'customPrice') { if(val \u003c 10000) { throw new Error(\"太低\") }else { target[key] = val return true } } } }) ","date":"2018-12-05","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:0:1","tags":["js设计模式"],"title":"js设计模式之代理模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"虚拟代理 图片预加载 var myImage = (function(){ var imgNode = document.createElement(\"img\") document.body.appendChild(imgNode) return { setSrc: function(src) { imgNode.src = src } } })() var proxyImage = (function(){ var img = new Image img.onload = function(){ myImage.setSrc(this.src) } return { setSrc: function(src) { // 占位图片 myImage.setSrc(\"http://123.png\") img.src = src } } })() // 通过代理设置图片地址，在onload之前会出现占位图片 proxyImage.setSrc(\"http://pic.jpg\") ","date":"2018-12-05","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:0:2","tags":["js设计模式"],"title":"js设计模式之代理模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"缓存代理 比如vue中的计算属性computed,它和methods的区别就是可以缓存数据 ","date":"2018-12-05","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:0:3","tags":["js设计模式"],"title":"js设计模式之代理模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":" 单例模式的定义: 保证一个类仅有一个实例，并且提供一个访问它的全局访问点。意义为减少内存开支，减少变量冲突。 ","date":"2018-12-04","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:0:0","tags":["js设计模式"],"title":"js设计模式之单例模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"常见的应用场景 全局的window对象，Jquery中的$对象 vuex和redux中的state 系统间各种模式的通信协调上 ","date":"2018-12-04","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:0:1","tags":["js设计模式"],"title":"js设计模式之单例模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"模式实现 最简单的实现，对象字面量的方法 let singleton = { age: 11, name: \"frank\" } 对象复杂的时候，就需要构造函数，简单的来说当new的时候先判断实例是否存在，如果存在直接返回，不存在就创建一个再返回，这样保证了返回的实例就是同一个。 class Singleton { constructor() { this.instance = null; } // 定义一个静态方法，实例化只能通过静态方法。 static getInstance(name) { if(!this.instance) { this.instance = new Singleton(); } return this.instance; } } let a = Singleton.getInstance() let b = Singleton.getInstance() console.log(a === b) ","date":"2018-12-04","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:0:2","tags":["js设计模式"],"title":"js设计模式之单例模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"模拟登陆框 class LoginForm { constructor { this.state = 'hide' } show() { // 如果当前已经显示 if(this.state === 'show') { alert('已经显示') return } this.state = 'show' console.log('登录框显示成功') } hide() { // 如果当前已经显示 if(this.state === 'hide') { alert('已经隐藏') return } this.state = 'hide' console.log('登录框隐藏成功') } } LoginForm.getInstance = (function(){ let instance return function () { if (!instance) { instance = new LoginForm() } return instance } })() // 测试 let login1 = LoginForm.getInstance() login1.show() let login2 = LoginForm.getInstance() login2.hide() ","date":"2018-12-04","objectID":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:0:3","tags":["js设计模式"],"title":"js设计模式之单例模式","uri":"/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":" 有的时候我们总是被JavaScript中的this搞得晕头转向，因为它的不确定性，也被经常拿来当作考题，我们也经常听到网上最认同的说法：“谁调用this,this就指向谁”，那么this到底是什么呢，最近就this总结了一下。 本篇文章主要参考《你不知道的JavaScript》（上） 话说草稿老早就写了，好像忘发了。 ","date":"2018-10-16","objectID":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/:0:0","tags":["JavaScript中的this"],"title":"总结一下JavaScript中的this","uri":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/"},{"categories":["JavaScript"],"content":"为什么要使用this？ 我们先要知道一个前提，在JavaScript中 万物皆对象，而函数在对象中又是 一等公民，对象与对象之间通过 原型联系，那对象和函数之间如何联系呢，答案就是 this 首先如果没有this会是什么情况？ // 只要切换上下文对象，就可以复用此函数，不用针对每个对象写一遍函数 function sayName(context){ console.log(context.name) } var me = { name: 'kyle' } var you = { name: 'frank' } // 如果没有this，我们只能显示的传入对象 sayName(me) // 函数的上下文为对象的情况 var obj = { name: 'frank' sayName: function(context) { console.log(context.name) } } // 如果没有this，我们只能显示的传入对象 obj.sayName(obj) 我们看到如果没有this，要想函数与对象产生关联，只能手动传入这个对象，那JavaScript的创始者想Java有个this，不如JavaScript也搞个this吧，干脆我就默认帮忙隐式传递这个对象得了！于是就发明了this这个关键字！ 所以结论是this关键字能够隐式的传递对象，当然了也提供了call,apply函数允许我们手动显式传递，上面的情况就可以这样写了。 var obj = { name: 'frank' sayName: function() { console.log(this.name) } } // 隐式传递了obj,等同于obj.sayName.call(obj) obj.sayName() ","date":"2018-10-16","objectID":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/:0:1","tags":["JavaScript中的this"],"title":"总结一下JavaScript中的this","uri":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/"},{"categories":["JavaScript"],"content":"那关于this指向的规则 一句话总结：调用位置决定了this的绑定对象;大概有四种情况： 默认绑定 隐式绑定 显示绑定 new绑定 默认绑定 也就是在全局作用域中调用则指向window（严格模式下为undefined） 可以认为在其他规则无法应用的下调用的默认绑定规则。 var a = '1' function foo() { console.log(this.a) // '1' } function foo() { 'use strict' console.log(this.a) // undefined } 隐式绑定 上面默认绑定的调用位置为全局，即调用位置的上下文对象为window，也有可能调用位置被其他上下文对象“包裹”，这时候js会帮你猜（隐式绑定）比如： var obj = { a: 1, foo: function() { console.log(this.a) // js猜你想用的是当前上下文中的这个a,所以就传给你。 } } 上面的上下文对象为obj,即this就会被隐式绑定到obj这个对象上 注意调用位置只作用于最后一次，比如如下: function foo() { console.log(this.a) } var obj2 = { a: 42, foo: foo } var obj1 = { a: 2, obj2: obj2 } obj1.obj2.foo(); 上面的例子中foo函数最后的调用位置为obj2中，所以最后打印出来的是42。 显式绑定 显示绑定就是使用JavaScript给我们提供的call,apply,和bind函数，手动指定this,指哪儿就是哪儿.比如： var obj = { a: 2, foo: function() { console.log(this.a) } } obj.foo.call({a: 10}) obj.foo.apply({a: 10}) obj.foo.bind({a: 10})() 以上我们使用call和apply手动的指定了this，即a为10； new绑定 首先简要概述一下new操作符干了什么 // 第一步：创建一个对象 var a = {} // 第二步：既然new出来的一个实例，肯定要挂到原型上即 a.__proto__ = F.prototype // __proto__是每个实例都具有的属性 // 第三步：改变this指向 F.call(a) // 第四步 return a 在第三步的时候，new就帮我们手动的改变了this的指向； ","date":"2018-10-16","objectID":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/:0:2","tags":["JavaScript中的this"],"title":"总结一下JavaScript中的this","uri":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/"},{"categories":["JavaScript"],"content":"优先级 this应用的这四种规则当然也有优先级 new绑定 \u003e 显示绑定 \u003e 隐式绑定 \u003e 默认绑定 ","date":"2018-10-16","objectID":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/:0:3","tags":["JavaScript中的this"],"title":"总结一下JavaScript中的this","uri":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/"},{"categories":["JavaScript"],"content":"总结一下 研究JavaScript中的this本来就没有太多意义，因为现在连箭头函数都舍弃了this，这都是JavaScript开始的坑，不过大体还是需要知道滴。 ","date":"2018-10-16","objectID":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/:0:4","tags":["JavaScript中的this"],"title":"总结一下JavaScript中的this","uri":"/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/"},{"categories":["JavaScript"],"content":" TypeScript主要提供了类型系统和对ES6的支持,对于一个需要长期维护的项目，使用TypeScript可以减少维护成本。使用VSCode编辑器，默认支持TypeScript，其次需要下载npm install -g typescript，因为我们需要tsc命令来将ts文件编译为js。 参考教程https://github.com/xcatliu/typescript-tutorial/blob/master/README.md ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:0:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"基本数据类型 布尔值、数值、字符串、null、undefined Symbol Symbol是ES6中的基本数据类型，返回的值为唯一 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:1:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"类型标注 我们声明变量可以如下声明 let a: boolean = false let b: string = '11' let c: number = 11 let d: null = null let e: undefined = undefined 当然还有 void ,如果一个变量声明为void，那么你只能将它赋值给null和undefined let a: void = null let a: void = undefined 另外undefined 和 null 是所有类型的 子类型 ，所以你可以将它们赋值给所有类型,下面都不会报错的。 let a: number = null let a: string = undefined let a: boolean = null 使用 any 指定任意类型 let a: any = '1' // 因为是任意类型，可以随意赋值，一下不会报错 a = 11 a = false 如果声明变量时(不赋值)没有指定类型即为默认any let a a = '1' a= 1 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:2:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"类型推论 类型推断顾名思义typescript会根据你在声明变量时的赋值，来推断变量的类型 let a = '1' a = 1 //会报错，因为ts已经推断变量a为字符类型 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:3:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"联合类型 联合类型表示取值可以为多种类型中的一种。使用 | let a: number | string a = 1 a = '1' 以上表示a可以是number或者string ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:4:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"类型别名 类型别名就是给类型取一个新的名字，使用type定义 type a = string type b = number let c: a | b ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:5:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"内置对象 ES里的内置对象 Boolean、Error、Date、RegExp 等，我们可以在ts中将变量定义为这些类型 let b: Boolean = new Boolean(1); let e: Error = new Error('Error occurred'); let d: Date = new Date(); let r: RegExp = /[a-z]/; DOM 和 BOM 的内置对象 Document、HTMLElement、Event、NodeList 等。 let body: HTMLElement = document.body; let allDiv: NodeList = document.querySelectorAll('div'); document.addEventListener('click', function(e: MouseEvent) { // Do something }); ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:6:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"对象类型-接口 接口是对行为的抽象，一般用类去实现，我们也可以用来定义对象； 对于对象来说，我们用接口来定义基本格式，那么对象必须满足这个格式，比如： // typescript推荐所有接口以I开头 interface Ia { name: string; age: number; } // 定义对象，使用Ia格式 let a: Ia = { name: 'a', age: 1 } // 如果类型不符合会报错,比如 let b: Ia = { name: 11, age: '1' } ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:7:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"可选属性 有时我们希望不要完全匹配一个格式，那么可以用可选属性： interface Ia { name: string; age?: number; } ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:7:1","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"任意属性 使用 [propName: string] 定义了任意属性取 string 类型的值。 interface Ia { name: string; age?: number; [propName: string]: any; } 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的子类型,也就是说name和age的类型必须这个任意属于类型的子类型，这么定义的any满足情况。 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:7:2","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"只读属性 我们只在刚刚创建的时候赋值，再修改就不可以了。 interface Ib { readonly x: number; } let b: Ib = { x: 1}; b.x = 5; // error! ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:7:3","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"数组类型 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:8:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"类型+[] 最简单的方法是使用「类型 + 方括号」来表示数组： // 声明一个number数组，如果有其他类型则会报错 let a: number[] = [1,2,3,4] ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:8:1","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"数组泛型 泛型之后会讲 let a: Array\u003cnumber\u003e = [1,2,3,4] ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:8:2","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"用接口表示数组 我们之前说过，接口就是抽象+格式,既然可以定义对象，数组同样也可以 interface INumberArray { [a: number]: number; } let a: INumberArray = [1，1，1，1] ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:8:3","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"使用any 用any表示数组可以出现任意类型 let a: any[] = [1,'2',{a: '11'}] ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:8:4","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"类数组 我想就是伪数组，比如arguments function abc () { // args 是伪数组 let args: IArguments = arguments console.log(args) } IArguments是typescript内部已经定义好的，除此还有NodeList, HTMLCollection 等 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:8:5","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"元组 元组较为数组更加严格，你可以规定元组第一个必须为string，第二个必须为number，如果不是则报错,比如 let a: [string, number] = ['1', 1] 顺序是必须匹配的，当然你也可以只赋值一项 let a: [string, number] a[0] = '12' 如果你越界赋值，则赋值类型就是已知的联合类型 let a: [string, number] = ['1', 1] a.push('11') // correct a.push(1) // correct a.push(true) // error true不是字符也不是数值 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:8:6","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"函数类型 函数的输入和输出都要约束到，函数定义有两种方式，函数声明和函数表达式 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:9:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"函数声明 // 函数声明 function a(x: number, y: number): number { return x + y } ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:9:1","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"函数表达式 // 函数表达式 let a = function (x: number, y: number) { return x + y } 上面的函数表达式的定义其实是不对的，虽然也能编译通过，因为它只是对右边进行了类型定义，左边只是通过赋值，typescript通过类型推论推断出来的，因此左边我们也要手动赋值 let a: (x: number, y: number) =\u003e number = function (x: number, y: number) { return x + y } =\u003e不是将头函数，在typescript中表示函数的返回值 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:9:2","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"接口形式定义函数格式 interface Ia { (a: number, b: number): number; } let d: Ia; d = function(a: number, b: number): number { return a + b } ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:9:3","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"可选参数 同样使用?,可选参数必须在必须参数后面 function a(x: number, y?: number): number { if(y) { return x + y } else { return x } } ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:9:4","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"参数默认值 y默认为1 function a(x: number, y: number = 1): number { return x + y } ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:9:5","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"剩余参数 使用…rest，获取函数中剩余的参数, items是一个数组，我们定义为任何类型 function push(array: any[], ...items: any[]) { items.forEach(function(item) { array.push(item); }); } let a = []; push(a, 1, 2, 3); ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:9:6","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"重载 重载就是函数名同名，我们根据参数类型不同来达到精确匹配。ts里面我们需要手动定义，最精确的写在前面。 function reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); } } ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:9:7","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"类 除了ES6中类一样外，TypeScript 还可以使用三种访问修饰符，分别是 public、private 和 protected。 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的。 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问。 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的。 比如下面，name是public，所以可以直接访问实例，如果不想被访问可以用private class Animal { public name; public constructor(name) { this.name = name; } } let a = new Animal('Jack'); console.log(a.name); // Jack a.name = 'Tom'; console.log(a.name); // Tom ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:10:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"抽象类 抽象类不允许被实例化，我们必须用子类继承它，并且如果抽象类里面定义了抽象方法，必须由子类实现 abstract class Animal { public name; public constructor(name) { this.name = name; } public abstract sayHi(); } class Cat extends Animal { public sayHi() { console.log(`Meow, My name is ${this.name}`); } } let cat = new Cat('Tom'); ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:10:1","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"声明文件 如果我们想使用第三方库比如jquery怎么办，ts并不认识$或者Jqyery,所以我们需要声明，这里我们使用declare关键字来定义，我们一般会把声明文件单独放到一个文件中 // jQuery.d.ts declare var jQuery: (string) =\u003e any; 然后在使用到的文件的开头，用「三斜线指令」表示引用了声明文件： /// \u003creference path=\"./jQuery.d.ts\" /\u003e jQuery('#foo'); 现在已经有很多的库不需要我们自己写声明文件了，我们下载时会自带声明文件，只要加上@types前缀就好，比如jquery npm install @types/jquery --save-dev ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:11:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"声明合并 如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型,当然类型必须一致 以接口为例 interface Alarm { price: number; } interface Alarm { weight: number; } 相当于 interface Alarm { price: number; weight: number; } ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:12:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"枚举 枚举使用enum关键字来定义，比如 enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; 枚举的值可以是常数也可以是计算的值，没有初始化会被默认赋值为0，下面的枚举成员的值会一次+1，如果赋值了的话，会根据赋值的值一次+1 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:13:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"常数枚举 常数枚举是使用 const enum 定义的枚举类型： const enum Directions { Up, Down, Left, Right } let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:13:1","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"外部枚举 外部枚举是使用 declare enum 定义的枚举类型： declare enum Directions { Up, Down, Left, Right } let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:13:2","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"泛型 泛型就是类型的变量，如果我们想输入什么类型，就要输出什么类型，就可以使用泛型，可能你会想到用any,但是这样其实失去了内部检查。 function identity(arg: any): any { return arg; } 这时候我们可以用泛型， function identity\u003cT\u003e(arg: T): T { return arg; } 我们输入的类型，那么T就是什么类型，输出就是这个类型。 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:14:0","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["JavaScript"],"content":"约束泛型 interface Lengthwise { length: number; } function loggingIdentity\u003cT extends Lengthwise\u003e(arg: T): T { console.log(arg.length); return arg; } 上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。 ","date":"2018-09-17","objectID":"/typescript%E5%85%A5%E9%97%A8/:14:1","tags":["TypeScript"],"title":"TypeScript入门","uri":"/typescript%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":" 最近好像流行零配置，parcel的开箱即用的概念，也影响了webpack4,在 webapck4中也开始朝着这个方向发展，比如默认的入口为src,默认的打包输出为dist,新增了mode属性，有利于拆分生产环境和开发环境，默认为production，并且默认压缩js，还有一些其他的插件也不再适用，在此也没必要了解，最近就从头梳理了一下webpack4. 本片文章主要参考自董沅鑫的个人博客https://godbmw.com ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:0:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"环境 首先我们要全局安装webpack-cli和webpack,然后也要在项目中安装webpack和webpack-cli,这样我们才能使用。 ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:1:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"编译ES6 编译es6,我们需要以下loaders babel-loader babel转换器 babel-core babel转换时所调用的api(听名字就知道它是babel的核心) babel-preset-env 语法转换规则 babel-plugin-transform-runtime和Babel-runtime polyfill按需引入 babel-polyfill polyfill全局引入 注意：在babel7中所有前缀都变为@babel/,注意版本的统一 新建webpack.config.js: const path = require(\"path\") // 使用babel编译ES6 module.exports = { entry: { app: \"./index.js\" // 以对象形式写推荐 }, output: { filename: \"bundle.js\", // resolve解析为一个绝对路径 path: path.resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.js$/, // 正则匹配以js结尾的文件 use: { loader: \"babel-loader\" // option: { // babel-loader的具体配置信息写在根目录下的.babelrc中 // } }, exclude: /node_modules/ // 排除依赖包 } ] } } babel的配置一般放在.babelrc中 { \"presets\": [ \"@babel/env\",{ \"targets\": { \"browsers\": [\"last 2 versions\"] } } ], \"plugins\": [\"@babel/plugin-transform-runtime\"] } presets配置中你可以具体指定，比如这里指定为浏览器上两个版本 我们知道用babel来转换es6语法，语法规则根据presets（预设的规则来的），但却转换不了es6的一些方法比如promise，generator函数，所以我们需要polyfill(垫片) 上面用的是按需引入polyfill,@babel/plugin-transform-runtime这个插件会去@babel/runtime中自动引入，所以即使打包后我们也用到@babel/runtime，它应该安装在生产环境中的依赖包中 如果要使用babel-polyfill的话，安装@babel/polyfill,并且在webpack.config.js中最开头引入即可，或者在写在入口函数字符串数组第一个 import '@babel/polyfill' // 或者 module.exports = { entry: [\"@babel/polyfill\",\"index.js\"] } ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:2:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"提取公共JS 在配置中新增optimization属性 const path = require(\"path\") // 多页面打包，提取公共代码 module.exports = { entry: { a: './a.js', b: './b.js' }, output: { filename: '[name].bundle.js', chunkFilename: \"[name].chunk.js\", // 非入口打包文件 path: path.resolve(__dirname, 'dist') }, optimization: { splitChunks: { cacheGroups: { commons: { name: 'common', // 提取公共chunk的名字 priority: 0, // 缓存优先级 chunks: 'initial', // 作用范围 minChunks: 2,//最小引用2次 minSize: 0 // 只要超出0字节就生成一个新包 }, vendor: { name: \"vendor\", test: /node_modules/, chunks: \"initial\", priority: 10, chunks: 'all' } } } } } 这里最重要的是priority属性，表示优先级的意思，上面我们就是先打包node_modules,打包后的名字为vendor,其次再打包Js,取名为common， 输出的时候也要注意加上ChunkFilename,表示非入口打包文件，抽离出的公共部分就是非入口打包文件 具体的其他属性，可以去官网去看看，这里只给出基本示例 ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:3:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"代码分割与懒加载 在入口文件中使用import()或者require.ensure()方法，webpack.config.js并不需要配置 示例 import(/* webpackChunkName: 'a'*/ \"./a\").then(function(a) { console.log(a); }); import(/* webpackChunkName: 'b'*/ \"b\").then(function(b) { console.log(b)); }); // 或者 require.ensure( [\"./a.js\", \"./b.js\"], function () { var a = require(\"./a\"); var b = require(\"./b\"); console.log(\"加载完成\") }, \"page\" ); 我们在vue中使用路由懒加载就是使用import() 我们在node中因为CommonJs规范为同步加载模块，我们使用的是require.ensure()来按需加载，其实这些方法我们以前就用过 ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:4:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"处理CSS ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:5:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"解析CSS 需要用到的loaders style-loader css-loader sass-loader/node-sass(以sass为例) const path = require(\"path\") module.exports = { entry: { app: './src/app.js' }, output: { filename: \"[name].bundle.js\", path: path.resolve(__dirname, \"dist\") }, module: { rules: [ { test:/\\.scss$/, use: [\"style-loader\",\"css-loader\",\"sass-loader\"]// 如果每个loader有配置，可以以对象形式书写 } ] } } ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:5:1","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"提取CSS 需要用到的loaders extract-text-webpack-plugin@next（注意后缀@next意为最新版） 或者mini-css-extract-plugin const path = require(\"path\") const ExtractTextPlugin = require(\"extract-text-webpack-plugin\"); module.exports = { entry: { app: './src/app.js' }, output: { filename: \"[name].bundle.js\", // []表示占位符 path: path.resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.scss$/, use: ExtractTextPlugin.extract({ fallback: { loader: \"style-loader\" // css编译后用什么来提取的loader }, use: [ { loader: \"css-loader\", options: { minimize: true // 是否压缩 } }, { loader: \"sass-loader\" } ] }) } ] }, plugins: [ new ExtractTextPlugin(\"[name].min.css\") // new ExtractTextPlugin({ // filename: \"[name].min.css\", // 压缩后的名字 // }) ] } ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:5:2","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"处理图片 通过CSS引入图片 style-loader和css-loder解析CSS,用url-loader解析图片 html标签插入图片（webpack不推荐这么引用） html-withimg-loader const path = require(\"path\") const webpack = require(\"webpack\") const ExtractTextPlugin = require(\"extract-text-webpack-plugin\"); module.exports = { entry: { app: \"./src/app.js\" }, output: { filename: \"app.[hash:8].bundle.js\", path: path.resolve(__dirname, \"dist\"), chunkFilename: \"[name].chunk.js\", publicPath: \"./\", // 资源引用路径 }, module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: { loader: \"style-loader\", // 回调style注入 options: { singleton: true } }, use: { loader: \"css-loader\",// 解析url()和@import options: { minimize: true } } }) }, { test: /\\.(png|jpg|jpeg|gif)$/, use: [ { loader: \"url-loader\", // 解析图片 options: { name: \"[name]-[hash:5].min.[ext]\", limit: 10000, // size \u003c= 20KB publicPath: \"static/\", outputPath: \"static/\" } } ] }, // 也可以对字体处理 { test: /\\.(eot|woff2?|ttf|svg)$/, use: [ { loader: \"url-loader\", options: { name: \"[name]-[hash:5].min.[ext]\", limit: 5000, // fonts file size \u003c= 5KB, use 'base64'; else, output svg file publicPath: \"fonts/\", outputPath: \"fonts/\" } } ] }, // html标签方式插入图片 { test: /\\.(htm|html)$/i, use:[ 'html-withimg-loader'] } ] }, plugins: [ // 压缩后CSS的名字 new ExtractTextPlugin(\"app.[hash:8].min.css\"), ], } ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:6:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"tree shaking js tree shaking module.exports = { // 设置为生产环境，自动调用插件 mode: \"production\" } css tree shaking 需要用到的loaders purifycss-webpack shaking主要插件 glob-all 帮助指示路径 extract-text-webpack-plugin 提取分离CSS const path = require(\"path\") const PurifyCSS = require(\"purifycss-webpack\"); const glob = require(\"glob-all\"); const ExtractTextPlugin = require(\"extract-text-webpack-plugin\"); module.exports = { entry: { app: \"./src/app.js\" }, output: { filename: \"app.[hash:8].bundle.js\", path: path.resolve(__dirname, \"dist\"), chunkFilename: \"[name].chunk.js\", publicPath: __dirname + \"/dist/\", }, module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: { loader: \"style-loader\", // 编译后使用style插入 options: { singleton: true } }, use: { loader: \"css-loader\", options: { minimize: true } } }) } ] }, plugins: [ new ExtractTextPlugin(\"app.[hash:8].min.css\"), new PurifyCSS({ paths: glob.sync([ path.join(__dirname, \".html\"), path.join(__dirname, \"src/*.js\") ]) }), ], } } ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:7:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"自动生成html\u0026\u0026清除打包缓存 const CleanWebpackPlugin = require('clean-webpack-plugin'); const htmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { plugins: [ // 字符串数组 new CleanWebpackPlugin(['dist']), // 生成html,并且自动引入 new htmlWebpackPlugin({ filename: \"index.html\", //打包后的文件名 template: path.join(__dirname , \"./index.html\") // 可以指定模板，如果是自定义的模板需要下载对于loader }), ], } ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:8:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"第三方js库 jquery为例 npm install jquery –save npm i expose-loader –save module.exports = { module: { { test: require.resolve('jquery'), use: [{ loader: 'expose-loader', options: 'jQuery' },{ loader: 'expose-loader', options: '$' }] } } } 然后在组件中可以这样引用 require('jquery') require('jQuery第三方插件') ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:9:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"webpack-dev-server module.exports = { devServer: { contentBase: path.join(__dirname, 'dist'), //启动路径 host:'localhost', //域名 port: 8888, //端口号 // 声明为热替换 hot: true, // 第一次打包时打开浏览器 open: true, compress:true, //压缩, overlay: true // 浏览器显示错误 //请求到 /api/users 现在会被代理到请求 http://localhost:9000/api/users。 // proxy: { // \"/api\": \"http://localhost:9000\", // } } } ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:10:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["工具"],"content":"生产环境和开发环境 我们可以把我们的webpack.config.js复制两份,使用mode属性来拆分成如下 webapck.dev.config.js mode:“development” webapck.pro.config.js mode:“production” 然后在package.json的书写脚本 { \"dev\": \"webpack --config webpack.dev.config.js\" \"build\": \"webpack --config webpack.pro.config.js\" } ","date":"2018-09-09","objectID":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/:11:0","tags":["webpack"],"title":"从头开始配置webpack4","uri":"/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEwebpack4/"},{"categories":["React"],"content":" redux和vuex一样，当项目数据复杂时，都是用来集中管理数据的，不过redux是单向数据流绑定,这就使得redux中的store必须放到所有组件最顶层，此篇文章是在看《深入浅出react与redux》以及实战React16.4开发简书项目后的总结。 ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:0:0","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["React"],"content":"Redux的前身flux 在flux中，首先要引入Dispatcher（redux没有这个）， 用以派发action，action改变view层，view层同步model数据层；flux会为每一个组件单独建立一个store，在每一个组件中初始化store,如下： const CounterStore = object.assign({}, EventEmitter.prototype, { getCounterValues: function() { return counterValues; }, emitChange: function(){ this.emit(CHANGE_EVENT); }, addChangeListener: function(){ this.on(CHANGE_EVENT, callback); }, removeChangeListener: fucntion(){ this.removeListener(CHANGE_EVENT, callback); } }) EventEmitter是node.js中event模块的一个对象，是监听事件的一个封装，不用太追究；上面扩展了EventEmitter.prototype，给当前组件的store绑定了几个事件；初始化store之后，还要与dispatcher做联系，这时候会用到dispatcher的一个register函数，接受参数为action； Dispatcher是唯一的，如果有很多个组件，Dispatcher与他们每一个组件都要做联系，通过waitFor函数来决定各个store之间的执行顺序，但这就是flux最大的缺点，因为如果store很多的话，依赖关系会越来越复杂，逻辑关系会难以维护。 ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:0","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["React"],"content":"Redux 在Redux中没有了Dispatcher的概念，store倒是有一个dispatch方法，用以来传递action给store 如图,解释一下流程 在组件内部会调用actionCreators，用于创建action对象，并且通过dispatch传送给store； store接受到后，会交给reducer（纯函数） 处理； reducer函数处理后会返回新的store状态； store里的数据发生变化会自动触发视图层变化，结束； 下面会一一解释store，reducer，action如何创建，并且如何走通。 首先创建一个store文件夹，下面会有四个js，分别是 index.js // 作为入口，统一引入到这里 actionCreators.js // 用来统一创建对象 constants.js // 统一定义action的type,方便后期维护log reducer.js // 用来处理action的纯函数 ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:0","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["React"],"content":"关于action 分割action为actionCreators和contants,方便管理维护 actionCreators.js import * as constants from './constants' // type为常量，从constants中引入，方便log export const sayHello = (text) =\u003e({ type: constants.SAY_HELLO， text }) constants.js export const SAY_HELLO = 'SAY_HELLO' 这个其实还是跟vuex中action一样的，很好理解。 ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:1","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["React"],"content":"创建store 调用createStore创建store，参数传入处理函数reducer import { createStore } from 'redux' import reducer from './reducer.js' // 调用createStore创建store，参数传入处理函数reducer const store = createStore(reducer); export default store ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:2","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["React"],"content":"编写reducer reducer默认接受state初始状态，和action对象，更改后的state import * as constants from './constants' // 设置state初始值 const defaultState ={ text: '' } // 默认暴露一个纯函数 export default (state = defaultState, action)=\u003e { switch(action.type) { case constants.SAY_HELLO: return {...state, action.text} default: return state } } 改有的文件都已经创建好，现在就可以捋一遍 首先在组件内部，我们想要改变store里的数据，首先要引入刚刚创建好的action，调用store的dispatch方法将action传递给store； // 引入store import store from './store' // 引入action import * as actionCreators from './actionCreators' // store.dispatch派发action store.dispatch(actionCreators.sayHello('你好！')) store收到action后会自动交给reducer处理，reducer根据其actionType的不同做不同的操作，并且返回更改后的st ate； export default (state = defaultState, action)=\u003e { switch(action.type) { case constants.SAY_HELLO: // 扩展运算符 return {...state, action.text} default: return state } } 组件内部通过store.subscribe()的方法能够监听store的变化，store一旦变化就可以调用store.getState()替换当前组件的store； // store数据变化后触发 handleCHange函数 store.subscribe(this.handleCHange) // handleCHange函数 替换组件内部store数据 handleCHange() { store.setState({ store.getState() }) } store里面的数据必须用setState更改，setState可以是一个对象，也可以是一个函数，return一个对象，后一种写法推荐，因为官网就是这么写的。 数据更新那么视图层就会自动更新，结束。 ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:3","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["React"],"content":"React-Redux 在react中有为react量身定做的react-redux库，其用法也有一些细微差别 ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:0","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["React"],"content":"react-redux自带的provider组件 \u003cProvider store={store}\u003e \u003cHello/\u003e \u003c/Provider\u003e 从组件根部传入store，在其所有子组件中都可以使用，具体如下： const mapStateProps = (state) =\u003e({ text: state.text }) const mapDispathProps = (dispath) =\u003e{ return { changeText() { //这里dispatch一个action } } } // 通过connect连接当前组件 export default connect(mapStateProps, mapDispathProps)(Hello) mapStateProps：顾名思义就是将state当作props传入当前组件； mapDispathProps：这个就是将Dispatch当作props传入组件； 这两个需要在组件外定义，然后当作参数传入connect中； ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:1","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["React"],"content":"combineReducers 一般一个组件都会定义一个store，那么多的store，里面有那么多的reducer.js,我们可以用combineReducer来合并； import { combineReducers } from 'redux' import { reducer as homeReducer } from '../store' const reducer = combineReducers({ header: homeReducer // 可以为每一个reducer取一个名字 }) 那么我们在组件获取状态时也要加上名字,改成如下： const mapStateProps = (state) =\u003e({ text: state.header.text }) ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:2","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["React"],"content":"快速开始模板 Github: https://github.com/mywebc/react_start ","date":"2018-08-29","objectID":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:4:0","tags":["redux"],"title":"redux快速入门","uri":"/redux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["vue"],"content":"在vue中使用elementUI中时表格，如何拿到单选或者多选（全选）的值？先记下一笔。 // 监听单选 val表示当前选中行， row表示所有的表格数据 selectChange(val, row) { let flag = 0 for(let i in val) { if(row.volumeNo === val.volumeNo) { // 如果已勾选，push进存值数组 flag = 1 break } } if (flag === 1) { this.codeList.push(row) } else { // 如果取消勾选，找到存值的数组并且删除 for(let i in this.codeList) { if(this.codeList.volumeNo === row.volumeNo) { this.codeList.splice(i, 1) } } } } // 监听全选, val表示所有数据， volumeNoData是在计算属性中请求的所有数据 selectAll (val) { var v = this if (val.length === 0) { for( let i in v.volumeNoData) { // 如果取消全选 for (let j in v.codeList) { if (v.codeList.volumeNo === v.volumeNoData.volumeNo) { v.codeList.splice(j, 1) } } } } if (v.codeList.length === 0) { //如果点了全选，而存值数组里为空的话，全部push for (let i in val) { v.codeList.push(val) } } else { // 否则一一对比，push没有的 for (let i in val) { let flag = false for(let j in v.codeList) { if(v.codeList.volumeNo === val.volumeNo) { flag = true break } } if(!flag) { v.codeList.push(val) } } } } ","date":"2018-06-28","objectID":"/vue%E4%B8%AD%E4%BD%BF%E7%94%A8elementui%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%8D%95%E9%80%89%E5%85%A8%E9%80%89/:0:0","tags":["elementUI"],"title":"vue中使用elementUI，表格的单选全选","uri":"/vue%E4%B8%AD%E4%BD%BF%E7%94%A8elementui%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%8D%95%E9%80%89%E5%85%A8%E9%80%89/"},{"categories":["JavaScript"],"content":"对象的语法的扩展 (1)对象的属性或属性值可以直接传入变量 let id = 12; let value = 22; let obj = {id:value} (2)在对象中方法的简写 //es5 let obj = { handle:function(){ //dosomething } } //es6 let obj = { handle(){ //dosomething } } (3)属性初始值简写 //ES5 function a(id) { return { id: id }; }; //ES6 const a = (id) =\u003e ({ id }) ","date":"2018-04-03","objectID":"/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/:0:1","tags":["es6"],"title":"ES6笔记（四）扩展对象的功能性","uri":"/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/"},{"categories":["JavaScript"],"content":"es6对象新增的方法 (1)Object.is() 比较两种数据类型，以前可以用===或者==，现在可以用Object.is()，不过Object.is()比较严格： console.log(+0 === -0) //true console.log(Object.is(+0, -0)) //false (2)Object.assign() Object.assign()这个方法早有接触过，合并对象以及浅拷贝,具体看如下示例： object.assign(target,...obj) 注意一下，obj中会覆盖target中重复的属性 ","date":"2018-04-03","objectID":"/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/:0:2","tags":["es6"],"title":"ES6笔记（四）扩展对象的功能性","uri":"/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/"},{"categories":["JavaScript"],"content":"对象被遍历自动枚举 示例： const state = { id: 1, 5: 5, name: \"eryue\", 3: 3 } Object.assign(state, null) //{\"3\":3,\"5\":5,\"id\":1,\"name\":\"eryue\"} 还有其他的object.keys()和for…in都会枚举。 ","date":"2018-04-03","objectID":"/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/:0:3","tags":["es6"],"title":"ES6笔记（四）扩展对象的功能性","uri":"/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/"},{"categories":["JavaScript"],"content":"对象原型的增强 Object.setPrototypeOf()还有super()。 ","date":"2018-04-03","objectID":"/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/:0:4","tags":["es6"],"title":"ES6笔记（四）扩展对象的功能性","uri":"/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/"},{"categories":["JavaScript"],"content":"函数参数的默认值 以前es5的做法是这样的： function log(x) { x = x || 10; console.log(x) } 这样做的坏处是有的时候我想传一个空字符，也会被修改为默认值 es6的做法直接在括号内写上默认值 function log(x=10) { console.log(x) } 这种写法就没有上面那种问题，需要注意的是函数参数一般会放在arguments里，你用ES6这种方法的话，arguments里面是没有滴。 ","date":"2018-04-02","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/:0:1","tags":["es6"],"title":"ES6笔记（三）函数","uri":"/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"reset参数 function say(a,b,...items){ // dosomething... } 当我们不知道参数个数时，可以用展开运算符…的形式，主义他只能放在最后一个参数的位置，而且他跟arguments不同，他是真数组，意味着你可以用Push，pop等方法。 ","date":"2018-04-02","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/:0:2","tags":["es6"],"title":"ES6笔记（三）函数","uri":"/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"箭头函数 ES6 允许使用“箭头”（=\u003e）定义函数。如下： var a = (v) =\u003e v; 两点注意： 函数参数没有或者只有一个时可以省略括号，返回值只有一个时也可以省略； （ 箭头函数没有自己的this，他的this指的是上下文的this,也就是说我们再也不用that = this或者self=this这样的形式了。当然箭头函数也要看场合使用，比如不要在object和原型里面定义箭头函数,因为这时候的this是指向window的。 ","date":"2018-04-02","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/:0:3","tags":["es6"],"title":"ES6笔记（三）函数","uri":"/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"尾调用优化 尾调用就是在函数的内部最后调用函数需要注意下面的都不算： // 情况一 function f(x){ let y = g(x); return y; } // 情况二 function f(x){ return g(x) + 1; } // 情况三 function f(x){ g(x); } 尾调用优化的原理： 当我们调用一个函数a时，在内存中会形成一个call frame（调用帧），里面记录着a的变量信息，如果在函数a里面再调用函数B,同样会形成一个call frame位于a的调用帧上方，如此嵌套调用，多个call frame就会形成call stack(调用栈)，所谓优化就是在a的调用帧之上b的调用帧如果用不到a里面的信息的话，a的调用帧就会舍弃掉。 注意：ES6中的尾调用优化只在use strict下生效，看下面例子： function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) // 120 ","date":"2018-04-02","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/:0:4","tags":["es6"],"title":"ES6笔记（三）函数","uri":"/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/"},{"categories":["JavaScript"],"content":"字符串 ","date":"2018-03-30","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":["es6"],"title":"ES6笔记（二）字符串和正则表达式","uri":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["JavaScript"],"content":"字符串模板 字符串模板用``来表示，示例如下: let template = `${变量1}` 可以看到字符串模板主要有两个特点 字符串换行不再需要+来拼接，里面的空格换行都会保留； 字符串里可以用${}的形式来表示变量，当然这里也可以写一些简单的表达式如${1+1}或是三元表达式${a=1?true:false},还可以调用函数${fn()}; ","date":"2018-03-30","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:1","tags":["es6"],"title":"ES6笔记（二）字符串和正则表达式","uri":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["JavaScript"],"content":"标签模板 标签模板的意思就是可以用函数来调用字符串模板，当然这个函数的参数有规定的。示例如下： //先定义这个函数 function tag (arr, ...arg){ //...表示不确定参数个数 console.log(arr); console.log(...arg); } // 准备一个变量 let world = 20; let sayHi= 66; // 函数调用 tag(hello, ${ world },${sayHi}) 从上面看出，这个函数的规则就是第一个参数是一个数组，里面放的是普通的字符串，而第二个参数就是${}里面的变量，一般用标签模板来过滤HTML字符串，了解即可，用的多的还是字符串模板。 ","date":"2018-03-30","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:2","tags":["es6"],"title":"ES6笔记（二）字符串和正则表达式","uri":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["JavaScript"],"content":"关于字符串编码 我们经常听到utf-8，它是一种通用的字符编码格式，但其实js里面对于字符串采用的是utf-16来处理的； 不管是utf-8还是utf-16都是Unicode码的一种实现，什么是Unicode码呢？不需要了解太多，你只要知道这是一个能代表任何字符的大集合就好了； 在js里字符的表示形式是这样的\\uxxxx,xxxx叫做码点，对于码点大于0XFFFF的字符来讲，ES5是不能正确处理的，ES6对此完善，并提供了一些API如下： codePointAt(index) //传入索引值，返回其对于位置的码点 String.fromCodePoint() //传入码点，返回对应字符串 at(index) //返回给定位置的字符 normalize() //顾名思义格式化，了解即可 ","date":"2018-03-30","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:3","tags":["es6"],"title":"ES6笔记（二）字符串和正则表达式","uri":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["JavaScript"],"content":"关于字符串的一些方法 有个印象就好，废话不多说上API: includes(str, index)//如果在字符串中检测到指定文本，返回true，否则false。 startsWith(str, index)//如果在字符串起始部分检测到指定文本，返回true，否则返回false。 endsWith(str, index)//如果在字符串的结束部分检测到指定文本，返回true，否则返回false。 str.repeat(n)//表示将字符串str重复n次 正则表达式 正则表达式主要增加了几个修饰符，几个属性，先不看，就是这么任性，因为看了也白看，而且现在用的也不多。以后有机会有精力再看吧。 ","date":"2018-03-30","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:4","tags":["es6"],"title":"ES6笔记（二）字符串和正则表达式","uri":"/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["JavaScript"],"content":"前言 在学习的过程中也用过不少ES6语法，比如箭头函数，promise，class等，但从来没有好好的从头捋一遍，es6是2015年出的，现在都2018了，再不好好看看就out了。 新的声明方式 let 在ES6中又出现了两种声明方式分别是let，和const，在此之前js的作用域只有全局作用域和函数包裹的作用域，而let的出现让js有了块级作用域，一个经典案例一看就明白： for(let i = 0;i\u003c 4;i++){ console.log(i) } console.log(i)//这里是i is not defined 可以看出用let来声明变量，其变量的作用域只存在于这个花括号内，此时花括号就是一个块级作用域，而如果用var声明的话，在外面是可以打印出i的值的，因为它仍然处于全局作用域下，所以我们平时在写代码时完全可以用let来代替var，现在js语法越来越严谨，var早晚会out的。还有要注意的是let不能重复声明变量以及不存在变量提升。 const const用来定义一些不可改变的变量，比如我用到的在node端引入一些包依赖用const const express = require('express'); const app = express(); 总之你不想他被改变就用const，而且他和let一样会形成块级作用域，不能重复声明，不存在变量提升。 ","date":"2018-03-30","objectID":"/es6%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%BB%91%E5%AE%9A/:0:1","tags":["es6"],"title":"ES6笔记（一）块级作用域的绑定","uri":"/es6%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%BB%91%E5%AE%9A/"},{"categories":["vue"],"content":"服务器 阿里云学生豪华套餐（centos系统） ","date":"2018-02-22","objectID":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/:1:0","tags":["vue"],"title":"vue/node搭建简易博客","uri":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/"},{"categories":["vue"],"content":"前端 vue-cli vue脚手架 vue-router 路由控制 vue-axios 发送请求 element-ui 饿了么图库 marked和highlight.js markdown语法 stylus css预处理 moment.js 一个时间格式库 lodash JavaScript工具库 ","date":"2018-02-22","objectID":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/:2:0","tags":["vue"],"title":"vue/node搭建简易博客","uri":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/"},{"categories":["vue"],"content":"后端 express 后端的jQuery cors 设置跨域 body-parse 获取post数据 mongoose mongo数据库 ","date":"2018-02-22","objectID":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/:3:0","tags":["vue"],"title":"vue/node搭建简易博客","uri":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/"},{"categories":["vue"],"content":"介绍 后端只负责提供API，API负责对mongo数据库的增删改查，注意用cors设置跨域限制； 前端为vue单页面，vue-router控制跳转，调用API获取数据并且展示。 本次练习进一步的熟悉了前后端分离开发。 ","date":"2018-02-22","objectID":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/:4:0","tags":["vue"],"title":"vue/node搭建简易博客","uri":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/"},{"categories":["vue"],"content":"演示地址(服务器到期) http://120.77.241.163 用户名：admin 密码：admin ","date":"2018-02-22","objectID":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/:5:0","tags":["vue"],"title":"vue/node搭建简易博客","uri":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/"},{"categories":["vue"],"content":"github https://github.com/mywebc/vueNodeBlog ","date":"2018-02-22","objectID":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/:6:0","tags":["vue"],"title":"vue/node搭建简易博客","uri":"/node%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/"},{"categories":["vue"],"content":"介绍 主要用到socket.io,前端用vue，后端用express转接消息 GitHub https://github.com/mywebc/VUE-Chat ","date":"2018-02-20","objectID":"/node%E8%81%8A%E5%A4%A9%E5%AE%A4/:0:0","tags":["vue"],"title":"vue/node聊天室","uri":"/node%E8%81%8A%E5%A4%A9%E5%AE%A4/"},{"categories":["vue"],"content":"打包注意点 在man.js中注释掉mode:history,这个只有在开启服务器下才有效； 在webpack.prod.config.js中把输出改为output:'./dist'; ","date":"2018-02-10","objectID":"/iview-cli%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84todolist/:0:1","tags":["vue"],"title":"iview-cli搭建，一个简单的todoList","uri":"/iview-cli%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84todolist/"},{"categories":["vue"],"content":"Github https://github.com/mywebc/todoLIst ","date":"2018-02-10","objectID":"/iview-cli%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84todolist/:0:2","tags":["vue"],"title":"iview-cli搭建，一个简单的todoList","uri":"/iview-cli%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84todolist/"},{"categories":["工具"],"content":"查看nginx是否启动 ps -ef | grep nginx //用ps -ef列出进程列表，然后通过grep过滤。 ps -C nginx -o pid //直接查看进程id ","date":"2018-01-24","objectID":"/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:1:0","tags":["nginx"],"title":"nginx常用命令总结","uri":"/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["工具"],"content":"nginx的启动，停止，与重载 nginx -s reload //修改配置文件后，可以重新热加载 nginx -s stop //快速停止，可能会丢失有关信息 nginx -s quit //有序停止 start nginx 或者 nginx开启nginx ","date":"2018-01-24","objectID":"/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:2:0","tags":["nginx"],"title":"nginx常用命令总结","uri":"/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["杂谈"],"content":" 目的：前端请求后端，插入数据到数据库。 新建两个文件夹，vueServer和vueClient vueServer 服务端用express搭建服务器，mongoose数据库存储 APP.js文件很简单 let express = require('express') let app = express() let router = require('./routes/router') let db = require('./models/db.js') let cors = require('cors') //静态资源管理 app.use(express.static(\"./public\")) // 设置跨域(*) app.use(cors()) // 设置路由 app.get('/users', router.doRegist) // 监听3000端口 app.listen(3000); router.js文件 let Users = require('./../models/users') // 路由逻辑 //注册业务 exports.doRegist = function (req, res, next) { //接受前台数据 var queryData = req.query var username = queryData.username var password = queryData.password // 查询是否有重复 Users \"username\": username }, function (err, doc) { if (err) { console.log(err); return; } if (doc.length != 0) { res.send(\"用户已经存在！\" ); } //写入数据库 else { Users.create({ \"username\": username, \"password\": password }, function (err, doc) { if (err) { console.log(err); return; } res.send(\"插入数据库成功！\"); }) } }) } 数据库文件 db.js let mongoose = require('mongoose') // 连接数据库 mongoose.connect('mongodb://localhost/users') let db = mongoose.connection // 监听连接状态 db.once('open', function () { console.log('数据库连接成功！') }) module.exports = db users.js let mongoose = require('mongoose') // 定义schema结构 let userSchema = new mongoose.Schema({ \"username\": String, \"password\": String }) // 利用schema生成模型 let Users = mongoose.model(\"Users\", userSchema) // 暴露出去 module.exports = Users vueClient 直接用脚手架生成，用axios发送请求 methods:{ doRegist() { // 获取用户名 let username = this.$refs.username.value let password = this.$refs.password.value if(username === \"\" || password === \"\") { alert(\"用户名或密码不能为空！\") } else { // 向后端发送请求，存入数据库 axios.get(\"http://192.168.43.54:3000/users\", { params: { \"username\": username, \"password\": password } }).then((response) =\u003e { if(response.status === \"200\") { console.log(\"注册成功！\") } }).catch((error) =\u003e { console.log(error) }) } } } } 最后localhost:8080能成功请求localhost:3000,并将数据插入到数据库。 ","date":"2017-12-18","objectID":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%B0%8Fdemo/:0:0","tags":["前后端分离"],"title":"前后端分离小demo","uri":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%B0%8Fdemo/"},{"categories":["杂谈"],"content":" 分享一下 http://2014.jsconf.cn/slides/herman-taobaoweb/#/ ","date":"2017-12-14","objectID":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E7%A6%BB/:0:0","tags":["前后端分离"],"title":"前后端为什么要分离？","uri":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E7%A6%BB/"},{"categories":["JavaScript"],"content":" 面试大概率会考到 // 你传入的应该是一个对象 function ajax(obj) { // 先判断是否是对象 if(obj instanceof Object){ // 设置一些默认值 obj.type = obj.type || 'get' obj.dataType = obj.dataType || 'json' obj.async = obj.async || 'true' // 将数据序列化 params = encodeUrl(obj.data) // 获取xhr对象 var xhr = getXhr() xhr.responseType=obj.dataType; if(obj.type === 'get') { obj.url = obj.url + '?' +params xhr.open('get', obj.url, obj.async) xhr.send() } if(obj.type === 'post') { xhr.open('post', obj.url, obj.async) xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded') xhr.send(params) } xhr.onreadystatechange = function(){ if(xhr.readystate === 4 \u0026\u0026 xhr.status === 200) { obj.success(xhr.responseText) }else { obj.error(xhr.status) } } }else { // 否则返回什么都不做 return obj } } // 获取xhr对象 function getXhr(){ if(window.XMLHttpRequest){ return new XMLHttpRequest() }else { return new ActiveXObject('Microsoft', XMLHTTP) } } // 将URL序列化，encodeURLComponent编码 function encodeUrl(params){ // 如果是对象的话 if(params instanceof Object){ var arr = \\[\\] for(var item in params){ arr.push(encodeURIComponent(item) + '=' + encodeURIComponent(params\\[item\\])) } // 再加一个随机数，避免浏览器缓存 arr.push('randNum=' + Math.random()) return arr.join('\u0026') }else { return params } } ajax({ url:'http://www.baidu.com', data:'get', dataType:'json', data:{ name:'haha', age: 12 }, success:function(data){ console.log('成功') }, error:function(data) { console.log(data) } }) ","date":"2017-12-12","objectID":"/%E5%8E%9F%E7%94%9Fjs%E5%B0%81%E8%A3%85ajax/:0:0","tags":["ajax"],"title":"原生js封装ajax","uri":"/%E5%8E%9F%E7%94%9Fjs%E5%B0%81%E8%A3%85ajax/"},{"categories":["JavaScript"],"content":"一、利用indexOf方法剔除 var newArr = [] function removeArr (arr) { for (var i = 0;i \u003c arr.length; i++){ // 如果等于-1的话，push进newArr if(newArr.indexOf(arr[i] === -1)) { newArr.push(arr[i]) } } return newArr } ","date":"2017-12-12","objectID":"/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/:1:0","tags":["js"],"title":"数组去重的三种方法","uri":"/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"二、利用sort方法相邻比较 function removeArr(arr) { // 先排序，这样相同的值都是相邻的 arr.sort() // 先把第一个值放进新数组 var newArr = [arr[0]] for(var i = 1;i \u003c arr.length;i++) { // 如果旧数组的值与新数组的值不一样就Push i f(arr[1] !== newArr[newArr.length - 1]) { newArr.push(arr[i]) } } return newArr } ","date":"2017-12-12","objectID":"/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/:2:0","tags":["js"],"title":"数组去重的三种方法","uri":"/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"三、利用对象属性名是否重复 ","date":"2017-12-12","objectID":"/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/:3:0","tags":["js"],"title":"数组去重的三种方法","uri":"/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"一、利用数组方法sort // 数组的sort方法，如果a\u003eb,则正序排，a ","date":"2017-12-11","objectID":"/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/:1:0","tags":["js"],"title":"数组内元素随机排序的三种方法","uri":"/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"二、经典的洗牌算法 // 我们先定义一个随机函数,用于取到x-y区间的随机数 function getRandom(min, max) { // +1是为了取到上限， return Math.floor(Math.random() * (max - min + 1) + min) } function shuffle(arr) { // for 循环，随机替换掉每一个数组元素 for(var i = 0; i \u003c arr.length; i++) { // 取一个随机数 var j = getRandom(0,arr.length) var x = arr[j] arr[i] = arr[j] arr[j] = x } return arr } ","date":"2017-12-11","objectID":"/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/:2:0","tags":["js"],"title":"数组内元素随机排序的三种方法","uri":"/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"三、push进新数组 // 递归思想，每执行一次，取一个数组索引的随机数，如此反复，直到数组长度为一，结束循环 function randomArr(arr, newArr) { if(arr.length === 1) { newArr.push(arr[0]) return newArr } // 取随机数 var random = Math.ceil(Math.random() * arr.length) - 1 // 随机push newArr.push(arr[random]) // 旧数组删除对应位置 arr[random].splice(random, 1) // 再次调用 return randomArr(arr, newArr) } ","date":"2017-12-11","objectID":"/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/:3:0","tags":["js"],"title":"数组内元素随机排序的三种方法","uri":"/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":["vue"],"content":" 慕课网上的vue项目，跟着做了20几天了， 因为提供不了node服务，歌单和歌词暂时请求不了， Github：https://github.com/mywebc/vuejs-music-player ","date":"2017-12-11","objectID":"/%E6%85%95%E8%AF%BE%E7%BD%91%E9%A1%B9%E7%9B%AE%E7%82%B8%E9%B8%A1%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/:0:0","tags":["vue"],"title":"慕课网项目：炸鸡音乐播放器","uri":"/%E6%85%95%E8%AF%BE%E7%BD%91%E9%A1%B9%E7%9B%AE%E7%82%B8%E9%B8%A1%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"},{"categories":["数据库"],"content":"介绍 mongo数据库是nosql（非结构性数据库）的一种，存储格式不是传统的表、行、字段，它的数据库是由多个集合组成，每个集合包含很多文档，每个文档就是一个json。具体的看下图就知道了： 所有的操作都是在命令行里操作的，当然网上也有很多可视化的工具，比如mongo VUE。 mongo下载地址：https://www.mongodb.com/download-center?jmp=nav#community mongoAPI文档：https://docs.mongodb.org/manual/ 下载安装好后，添加mongo环境变量，在命令行里输入mongod –dbpath f:\\mongo,开启数据库，路径为f:\\mongo， 另起命令行窗口，输入mongo连接数据库，接下来就可以进行以下操作了。 其它基础命令： show dbs:查看所有数据库 db:查看当前数据库 use student:切换到student数据库，如果没有则创建 db.student.drop();删除student集合 db.dropDatabase();删除当前所在数据库 db.getCollectionNames();获取当前数据库下的所有文档 cls:清屏 ","date":"2017-11-02","objectID":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:0:1","tags":["mongo"],"title":"mongo数据库增删改查方法总结","uri":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["数据库"],"content":"插入 db.student.insert({“name”:“小明”}); 可以在外面写好json文件，使用命令导入： mongoimport –db test –collection restaurants –drop –file primer-dataset.json -db test 想往哪个数据库里面导入 –collection restaurants 想往哪个集合中导入 –drop 是否把集合清空 –file primer-dataset.json 哪个文件 ","date":"2017-11-02","objectID":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:0:2","tags":["mongo"],"title":"mongo数据库增删改查方法总结","uri":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["数据库"],"content":"查找 db.restaurants.find() 精确匹配： db.student.find({“score.shuxue”:70}); 多个条件： db.student.find({“score.shuxue”:70 , “age”:12}) 大于条件： db.student.find({“score.yuwen”:{$gt:50}}); 或者。寻找所有年龄是9岁，或者11岁的学生 db.student.find({$or:[{“age”:9},{“age”:11}]}); 查找完毕之后，打点调用sort，表示升降排序。 db.restaurants.find().sort( { “borough”: 1, “address.zipcode”: 1 } ) ","date":"2017-11-02","objectID":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:0:3","tags":["mongo"],"title":"mongo数据库增删改查方法总结","uri":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["数据库"],"content":"修改 先要找到再修改，使用$set db.student.update({“name”:“小明”},{$set:{“age”:16}}); 查找数学成绩是70，把年龄更改为33岁： db.student.update({“score.shuxue”:70},{$set:{“age”:33}}); 更改所有匹配项目：添加multi: true： db.student.update({“sex”:“男”},{$set:{“age”:33}},{multi: true}); 完整替换，不出现$set关键字了： db.student.update({“name”:“小明”},{“name”:“大明”,“age”:16}); ","date":"2017-11-02","objectID":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:0:4","tags":["mongo"],"title":"mongo数据库增删改查方法总结","uri":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["数据库"],"content":"删除 db.restaurants.remove( { “borough”: “Manhattan” } ) 只删除一个： db.restaurants.remove( { “borough”: “Queens” }, { justOne: true } ) ","date":"2017-11-02","objectID":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:0:5","tags":["mongo"],"title":"mongo数据库增删改查方法总结","uri":"/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["Node.js"],"content":"模块化是一种开发模式，模块化的开发有利于后期维护，提高效率，模块化的规范在服务器端是CommonJs，比如nodejs采用的就是这个，在浏览器端有AMD规范（比如RequireJs采用的），CMD规范（SeaJS采用的）。 SeaJS我看了一点，但是我又忘得差不多了o(╥﹏╥)o，我知道错了，所以我来做笔记了。 在SeaJs中它是用define定义模块的： define(function(require,exports,module) { var a=1; exports.text=a; //或者 module.exports={text:a}; }) 三个参数： require：用来加载模块的; exports：module 的别名，只能通过点语法加属性； module:是一个对象，里面有exports这个属性； 所以exports=module.exports; 我们在使用中用exports或者module.exports暴露接口都可以。 具体的基本使用是这样的： 引入sea.js库； 用define定义模块，在里面向外面暴露接口； 也是在define中，用require加载定义的模块； 启动模块系统，seajs.use(),引入入口模块； 有点跑题了，本篇主要是书写nodejs中的require的方法的，nodejs中的模块的定义比seajs简单点，不需要define，一个js文件就是一个模块，同样用exports暴露接口，require加载模块。 下面我们自己重写requie函数： //使用严格模式 'use strict' function myrequire(id) { //引入node内部模块fs和path const fs = require('fs'); const path = require('path'); //包含自身的完整路径 const filename = path.join(__dirname, id); // pathto/module1.js //不包含自身的路径 const dirname = path.dirname(filename); // pathto //为防止node把他丢到事件队列里，这里需要同步读取 let code = fs.readFileSync(filename, 'utf8'); // 定义一个数据容器，用容器去装模块导出的成员 let module = { id: filename, exports: {} }; let exports = module.exports; // module.exports code =` (function(myrequire, module, exports, __dirname, __filename) { ${code}})(myrequire, module, exports, dirname, filename);`; //转换成js代码 eval(code); return module.exports; } 再拓展解释一下上面的代码： node是只运行在V8引擎的，所以不存在兼容性问题，node在严格模式下可以用很多ES6的语法，所以你会看到let,const或是箭头函数，模板字符串的用法； node有很多内置的模块，不需要我们定义可以直接使用，比如fs,path; node的事件驱动简单的来说，先执行同步（阻塞）代码，再执行异步（非阻塞）代码。异步分为异步I/O和异步非I/O，异步非I/O就是settimeout这种，满足一定条件后才会执行，异步I/O就是fs这种读写文件的操作。 所以它大体是这样执行代码的：先由上到下扫一遍，同步的都执行完，异步事件都扔到事件队列里，异步非I/O满足条件就执行，否则再往下走，遇到fs读写操作会交给子线程完成，自己再往下走，因为万一读的文件非常大呢？岂不耽误我主线程做事？ 这种耗时的事情还是让小弟去做吧！最后子线程会以回调函数的形式返回执行结果。 其实node的require模块是有缓存机制的，当它第二次加载时会直接读取缓存里的module.exports，所以上面的方法我们还需要加入一个缓存机制，改为： //使用严格模式 'use strict' function myrequire(id) { //引入node内部模块fs和path const fs = require('fs'); const path = require('path'); //包含自身的完整路径 const filename = path.join(__dirname, id); // pathto/module1.js //不包含自身的路径 const dirname = path.dirname(filename); // pathto //判断是否有缓存，有的话赋值。 myrequire.cache = myrequire.cache || {}; if (myrequire.cache[filename]) { return myrequire.cache[filename].exports; } //为防止node把他丢到事件队列里，这里需要同步读取 let code = fs.readFileSync(filename, 'utf8'); // 定义一个数据容器，用容器去装模块导出的成员 let module = { id: filename, exports: {} }; let exports = module.exports; module.exports code =` (function(myrequire, module, exports, __dirname, __filename) { ${code}})(myrequire, module, exports, dirname, filename);`; //转换成js代码 eval(code); // 将结果缓存起来 myrequire.cache[filename] = module; return module.exports; } 这里用到require.cache，打印它，里面是一个filename为键的对象，我们的缓存在exports中,所以每次进来只要判断一下就好了 当然你想删除require.cache里的缓存也可以，不过一般不这么做： 遍历循环里面的每一项，用delete关键字删除。 Object.keys(require.cache).forEach(key)=\u003e{ delete require.cache[key]; } ","date":"2017-10-26","objectID":"/nodejs%E4%B8%AD%E4%B9%A6%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84require%E6%96%B9%E6%B3%95/:0:0","tags":["node.js"],"title":"nodejs中书写自己的require方法","uri":"/nodejs%E4%B8%AD%E4%B9%A6%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84require%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"对于angular，还是先放放，国庆期间看了点VUe.js,最近这两天在FCC（free code camp）刷题，以前学的知识又忘了，看到数组的几个方法怕记不住，还是写下来吧。 插入与删除 push：末尾插入； pop:末尾删除； shift:开头删除； unshift:开头添加； map 迭代数组，在回调函数中处理相关逻辑，并且返回新数组，不会改变原来数组 比如： var oldArray = [1,2,3,4,5]; var newArray = oldArray.map(function(val){ return val+3; }); reduce 迭代数组，作用将数组累加到一个值中，两个常用参数（总共4个），preValue和currValue; 比如： var array = [4,5,6,7,8]; var singleVal = 0; singleVal = array.reduce(function(pre,curr){ return pre+curr; },0); filter（过滤器） var oldArray = [1,2,3,4,5,6,7,8,9,10]; var newArray = oldArray.filter(function(val){ return val\u003c6; }); sort 方法，你可以很容易的按字母顺序或数字顺序对数组中的元素进行排序。 比如：从小到大排列 var array = [1, 12, 21, 2]; array.sort(function(a, b) { return a - b; }); reverse 方法来翻转数组，无参数。 比如： var array = [1,2,3,4,5,6,7]; var newArray = []; newArray = array.reverse(); concat,将两个数组内容合并到一个数组中去。 比如：用concat 把 otherArray 拼接在 oldArray 的后面： newArray = oldArray.concat(otherArray); split将指定字符串分割成数组 split（“”）单个字符分割 split（“ ”）以空格分割 他还有第二个可选参数，规定返回多少个数组。 join，将数组转化成字符串，并且可以指定连接符 var joinMe = [\"Split\",\"me\",\"into\",\"an\",\"array\"]; var joinedString = ''; joinedString = joinMe.join(' '); ","date":"2017-10-11","objectID":"/js%E4%B8%AD%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/:0:0","tags":["js"],"title":"js中对数组的一些操作","uri":"/js%E4%B8%AD%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"},{"categories":["CSS"],"content":" 我们可以看到这个游戏由背景蓝天，土地，小鸟，管道四部分组成，在开始游戏我们必须保证全部加载完所有图片资源，这里书写一个函数传进所有图片资源，再通过回调函数的方式返回加载好的图片资源 // 思路： // （1）遍历imgUrl,统计imgUrl次数，创建img对象 // （2）调用img对象onload方法，所有加载完成后给fn function loadedImg(imgUrl,fn){ // 用来保存图片资源 var imgObj={}; var tempImg,loaded=0,imgLenght=0; for(var key in imgUrl){ // 每循环一次加一下，统计次数 imgLenght++; // 获取img对象 tempImg=new Image(); // 把所有图片资源依次循环赋值temImg.src tempImg.src=imgUrl\\[key\\]; // 然后再把这张图片依次存入imgObj imgObj\\[key\\]=tempImg; // 注册所有图片加载事件 tempImg.onload=function(){ // 统计加载的次数 loaded++; // 如果加载的次数与之前循环的次数相同的话，说明所有图片加载完毕 if(loaded=imgLenght){ // 把加载的资源给回调函数 fn(imgObj); } }; } } 绘制背景 和轮播图差不多，准备两张相同的背景图，在计时器里调用上下文对象的drawImg（）方法不断的向左偏移重绘即可，其构造函数如下 // 书写绘制背景函数 function Sky(ctx,img,speed){ this.ctx=ctx; this.img=img; this.width=this.img.width; this.height=this.img.height; Sky.len++; this.x=this.width * (Sky.len-1); this.y=0; this.speed=speed||2; } Sky.len=0; // 给原型增加方法 Sky.prototype={ // 重新指向构造函数 constructor: Sky, // 绘制背景 draw:function(){ this.ctx.drawImage(this.img,this.x,this.y); }, update:function(){ // 让它往右走 this.x-=this.speed; if(this.x\u003c-this.width){ this.x += this.width * Sky.len; } } } //我们再在loadImg函数中调用即可 // 先把图片调用出来 loadedImg({ beiJing:'./images/sky.png', bird:'./images/bird.png', land:'./images/land.png', pipeDown:'./images/pipeDown.png', pipeUp:'./images/pipeUp.png', }, function(imgObj){ // 实例化天空 var sky=new Sky(vas,imgObj.beiJing,2); var sky2=new Sky(vas,imgObj.beiJing,2); // 让canvas的宽高与背景图自适应 ctx.width=imgObj.beiJing.width; ctx.height=imgObj.beiJing.height; // 让背景动起来 setInterval(function(){ //第一张图片 sky.update(); sky.draw(); //第二张图片 sky2.update(); sky2.draw(); },50) }) 绘制大地同理 绘制小鸟同理，需要额外为画布添加一个点击事件，点击时让小鸟的this.y(y轴坐标)往上移动。 绘制管道的思路：每一组的管道，上管道和下管道的长短随机生成，但是中间的间距是一定的，我们将中间的距离固定，上管道的长为随机生成，下管道的长即画布高减去大地高减去中间间距即可也是随机的，让它移动起来方法也是和前面一样的。 ","date":"2017-09-30","objectID":"/canvas%E5%B0%8F%E6%A1%88%E4%BE%8Bfly-birds/:0:0","tags":["canvas"],"title":"canvas小案例：fly birds","uri":"/canvas%E5%B0%8F%E6%A1%88%E4%BE%8Bfly-birds/"},{"categories":["CSS"],"content":" canvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 基本语法： 使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸. 默认 canvas 的宽高为 300 和 150. 不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性. 如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力. canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题. canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api. 基本使用方法： 获得 canvas 对象. 调用 getContext 方法, 提供字符串参数 ‘2d’. 该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令. 使用 CanvasRenderingContext2D 对象提供的方法进行绘图. 基本绘图命令 设置开始绘图的位置: context.moveTo( x, y ). 设置直线到的位置: context.lineTo( x, y ). 描边绘制: context.stroke(). 填充绘制: context.fill(). 闭合路径: context.closePath(). 示例： var canvas = document.createElement( 'canvas' ); canvas.width = 500; canvas.height = 400; canvas.style.border = '1px dashed red'; document.body.appendChild( canvas ); // 获得 CanvasRenderingContext2D 对象 var context = canvas.getContext( '2d' ); // 设置 起点 context.moveTo( 0, 0 ); // 绘制直线 context.lineTo( 500, 400 ); // 设置 起点 context.moveTo( 0, 400 ); // 绘制直线 context.lineTo( 500, 0 ); // 描边显示效果 context.stroke(); 其他常用API： （一）绘制线型 canvas.lineWidth=number //设置线宽 canvas.lineCap=‘butt’( 默认 ), ‘round’, ‘square’ //设置线末端的样式 canvas.lineJoin=‘round’（圆角）, ‘bevel’（平切）, ‘miter’(默认)（直角） //设置线末端的连接方式 canvas.lineDashOffset=number //虚线起始偏移量 canvas.setLineDash（） //设置虚线偏移量，数组形式，可以传多个参数 canvas.getLineDash（） //获取虚线偏移量，以数组形式返回 canvas.strokeStyle=value //设置描边的颜色 canvas.fillStyle=value //设置填充的颜色 这里注意：要先填充，再描边 （二）绘制形状 绘制矩形： canvas.strokeRect(x,y,width,height) //x,y表示矩形左上角坐标，后面两个参数表示宽高，此方法只是画出了路劲，还需要描边。 canvas.fillRect(x,y,width,height) //参数与上面相同，这个是填充矩形，默认填充颜色为黑色。 canvas.clearRect( x, y, width, height ) //参数与上面相同，清除目标矩形区域内的内容。 绘制圆弧： canvas.arc( x, y, radius. startAngle. endAngle, anticlockwise ) //x,y表示圆心，radius表示半斤，后面两个表示起始角度，最后一个表示方向默认为正，传入true为逆时针。 注意：开始绘制圆弧前，如果设置了moveTo，就会形成圆弧。 绘制文本： canvas.fillText( text, x, y,maxWidth]) //填充文本，text为文本信息，x,y表示绘制的起点坐标，maxWidth表示限制文本最大宽度，一般不设他会自动设置。 canvas.strokeText( text, x, y,maxWidth]) //描边文本，参数值与上面相同。 canvas.measureText() //获取文本的一些信息，返回TextMetrics对象.这个对象有很多属性，常用width等。 canvas.font（） //设置字体的一些信息，语法与CSS相同，其顺序可以是: style | variant | weight | size/line-height | family. canvas.textAlign（）//设置文字对齐方式， start( 默认 ), end, left, right, center. canvas.textBaseline（） //设置字体垂直对齐方式，可以取值： top, middle, bottom, hanging, alphabetic（字母基线）, ideographic（表意对齐） 绘制图形： canvas.drawImage( img, dx, dy ) //img是图像对象，可以是img ，video，或者是另一个canvas，x,y为放置的位置。 注意这里的图片对象必须是已经加载完的，可以把它放到onload事件里。 canvas.drawImage(img, dx, dy, dWidth, dHeight) //与上面不同的是，这里多了两个参数指定图像宽高，这样是可以压缩图形的。 canvas.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) //这里面的意思就是把前面指定图像中的位置，剪切下来放到canvas指定区域中去。 （三）变换 canvas.scale(x,y) a)参数 x 控制水平缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大. B)参数 y 控制垂直缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大. canvas.translate(x,y) a)x 表示水平移动, 正数向右, 负数向左. b)y 表示垂直移动, 正数向下, 负数向上. canvas.rotate(radian) 正数表示顺时针旋转, 负数表示逆时针旋转. canvas.transform(a,b,c,d,e,f) a)其中 a 有时又标记为 m11. 它表示水平缩放. 其中 b 有时又标记为 m12. 它表示水平倾斜. 其中 c 有时又标记为 m21. 它表示垂直倾斜. 其中 d 有时又标记为 m22. 它表示垂直缩放. e)其中 e 有时又标记为 dx. 它表示水平移动. f)其中 f 有时又标记为 dy. 它表示垂直移动. canvas.setTransForm(a,b,c,d,e,f) a)他会重置transform属性，只会影响后来的变换，会以相同参数运行transform（）； （四）保存和回滚 canvas.save()//保存状态 canvas.restore()//回滚上一次的状态 这里注意：如果 save 两次, 就需要 restore 两次, 才可以恢复到最先的状态. 绘制好后的canvas保存 直接右击另存为 或者使用 js 代码将其保存为 base64 编码的字符串Canvas.ToDataURL( type, encoderOptions )type 表示输出类型. 例如: image/png 或 image/jpeg 等encoderOptions 表示图片输出质量, 其取值在 0 到 1 之间. 如果是 1, 表示无损压缩, 必须使用 image/jpeg 或 image/webp 才起作用 （五）渐变和图案 canvas.createLinearGradient( x0, y0, x1, y1 ) 该方法返回一个 CanvasGradient 对象. 用于描述渐变的方式. 该方法有两个参数, 用于表示线型渐变的方向与位置. 使用的时候, 首先创建一个 CanvasGradient 对象, 然后利用 addColorStop 方法添加颜色区间. 方法语法: CanvasGradient.addColorStop( rate, color ). 该方法用于设置在某个比例位置的颜色是什么. rate 的取值是 0 到 1 之间. 可以添加多个渐变点. 然后将该对象赋值给 *Style 属性即可. 示例： var canvasGradient = ctx.createLinearGradient( 0, 25, 200, 25 ); canvasGradient.addColorStop( 0, 'blue' ); canvasGradient.addColorStop( 1, 'red' ); ctx.fillStyle = canvasGradient; ctx.fillRect( 0,","date":"2017-09-26","objectID":"/canvas%E7%94%BB%E5%9B%BEapi%E6%95%B4%E7%90%86/:0:0","tags":["canvas"],"title":"canvas画图API整理","uri":"/canvas%E7%94%BB%E5%9B%BEapi%E6%95%B4%E7%90%86/"},{"categories":["CSS"],"content":" 动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 在CSS3中的设置动画步骤： a、通过@keyframes指定动画序列； b、通过百分比将动画序列分割成多个节点； c、在各节点中分别定义各属性 d、通过animation将动画应用于相应元素； 示例： //定义规则 @keyframes move{ //move为规则名称 from{ background-color:yellow; } to { background-color:red; } } //也可以以百分比的形式，设置多个节点 @keyframes move{ 0%{ background-color:yellow; } 50% { background-color:red; } 75% { background-color:green; } } //最后在animation属性里应用 .div { animation:move 1s; } animation 中的属性简述 animation-name设置动画序列名称； animation-duration动画持续时间； animation-delay动画延时时间； animation-timing-function动画执行速度，linear(平均)、ease（慢快慢）、ease-in（慢快）、ease-out（快慢）、cubic-bezier(自定义速度)； animation-play-state动画播放状态，running、paused; animation-direction动画逆播，normal（正常，动画结束回到第一帧），reverse（与normal相反），alternate（动画完成，在倒放逆播），alternate-reverse（与alternate相反）； animation-fill-mode动画执行完毕后状态，forwards（保持最后一帧的状态）、backwards（回到第一帧）； animation-iteration-count动画执行次数，可以是1、2、3…inifinate表示无数次； steps(60) 这里表示动画分成60步完成,一帧一帧的进行，这是第一个参数，第二个参数（可选）为start或end，默认情况下为end; 关于start和end 的区别：他们都规定了动画时间变化点，start是在两帧跳换前，end是在两帧跳换后； 比如：分两步，0%-100%，盒子颜色变化从红色变到绿色 如果设置start，他在0%跳换前，动画就执行了，所以我们刷新页面一进去就看到绿色，设置end的话，我们会一直看到红色，0%前动画不会执行，跳到100%后动画结束，这是绿色状态不可见的，还会变成红色。 总之，如果3s的动画执行时间，start和end的区别就是，到底是在3s前就执行，还是在3s后执行的区别。 参数值的顺序： 关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意 最后2个小例子熟悉一下： CSS3设置帧动画达到钟表效果： ","date":"2017-09-17","objectID":"/%E7%AE%80%E8%BF%B0css3%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB/:0:0","tags":["CSS3"],"title":"简述CSS3中的动画","uri":"/%E7%AE%80%E8%BF%B0css3%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB/"},{"categories":["CSS"],"content":" 一般我们在页面中的布局都用浮动或是定位来解决，但是浮动的初衷是解决文字环绕图片的问题，但是现在CSS3中出现了flexbox布局，一个真正为布局而出现的解决方案； 一、如何成为弹性盒子（flexbox）? 我们只要给父容器设置display:flex||inline-flex即可，这时候，父容器就是flex container（弹性容器）,里面的子元素就是flex item（弹性子元素）;还有一些其他名词我们也需要了解，如下图（图片资源来自于网络）： 在这个弹性容器中我们有两个轴main axis（主轴）从左到右，cross axis（侧轴）从上到下，axis就是轴的意思，来跟我念\"阿克色死\"，主轴开始的地方叫main start,结束的地方叫main end,侧轴同理也有cross start和cross end，在主轴中子元素所占据的空间叫main size，同理侧轴叫cross size。 二关于flex在父容器中应用的属性 flex-direction：row（默认）||row-reverse||column||column-reverse;规定弹性子元素在主轴或侧轴的起始方向。 看如下代码， \u003cdiv class=\"container\"\u003e \u003cdiv class=\"one\"\u003eone\u003cdiv\u003e \u003cdiv class=\"two\"\u003etwo\u003cdiv\u003e \u003cdiv class=\"three\"\u003ethree\u003cdiv\u003e \u003cdiv\u003e 效果图如下： 然后我们给父容器添加四个属性， 说明： 第一个就是设display：flex后它的默认效果相当于flex-direction：row， 第二个是row-reverse，第三个是column，第四个是column-reverse flex-wrap：nowrap||wrap||wrap-reverse; 这是个换行属性，规定如果一条轴线上放不下子元素，是否换行，换到上面还是下面。 现在我一行放四个，四个div的宽度已经超过了父容器的宽度，看看这个属性怎么用的如图： 说明：第一个是nowrap不换行，第二个是wrap换行，第三个也是换行，区别是原来是第一行到第二行，现在是第二行到第一行，记住reverse就是反向的意思。 flex-flow: || ; 这个属性可以将前面两个合并起来写，默认就是row nowrap justify-content: flex-start || flex-end || center || space-between || space-around; 规定了子元素在主轴的对齐方式 话不多说看图吧：说明：从第一张到到最后一张属性：flex-start（默认）、flex-end、center、space-between、space-around，第四个和第五个区别就是，第四个把多余的空间部分平均分配但不包括收尾项，第五个包括收尾项。 align-items:flex-start||flex-end||center||baseline||stretch; 有主轴的对齐方式也有侧轴的对齐方式啦。 直接上图演示： 说明：前面三张图不用解释了吧，第四张呢css-tricks上是这样解释的baseline: items are aligned such as their baselines align; 翻译过来就是项目对齐正如他们的基线对齐，我想应该就是以他们里的文字为基准对齐，第五个在不设置高度的情况下(也是默认情况下)生效，strench即拉伸,子元素高度撑满父容器。 align-content:flex-start||flex-end||center||space-between||space-around||stretch; 如果是多轴线，对所有元素规定对齐方式，是单轴线的话不起作用。 看图：说明：属性与图都是是一一对应的，这里的属性前面都讲过，看看图就明白了。 三、关于flex在字元素中应用的属性 order：integer; 规定子元素的排列顺序。所有元素默认都是0，就看谁是老大，谁就排在最后。 看！这里我把第一个元素order设为1，它就排到最后了，其他的默认都是0。 algin-self 它老爸是algin-items，所以呢他们有相同的属性值，只是这个属性针对的是单个元素，还有呢他会多一个默认的auto属性值，表示继承老爸的属性，如果他没老爸，默认就是strench,这里就不演示了。 flex-grow:number; 定义子元素的放大比例。 这个属性所有的元素都是默认为0的，就是保持不变，如果有一个元素为1或者更大，他就会占满剩余空间，看下面两张图就知道了： 这里我把第五个div的flex-grow设为1,2,或1000它都是这样，只要其他的都是0; 再看下图： 这里我把所有的子元素flex-grow设置为2，第五个子元素单独设置为1 ，可以看到在第一行他们平均分配，因为他们都是2;在第二行值为2的是值为一的双倍，因为比例是12，所以看到第四个是第五个的双倍，这个比例如果是3/4,4/5,….越来越接近1的话，他们的长度也会越来越接近。这里注意负值无效，就是默认为0了。 flex-shrink:number; 有放大就有缩小，这个属性规定了子元素的缩小比例，默认为1。如果一个子元素的值为0，那么他的宽度就是固定的，如果他的值是1,2,3,..值越大，缩小比例越小。 flex-basis:auto||length; 定义我们子元素在放大或缩小前的尺寸，可以是**px形式，定义好后，我们的放大或缩小将以这个为基准，这个没什么好说的。 flex: none | [ \u003c‘flex-grow’\u003e \u003c‘flex-shrink’\u003e? || \u003c‘flex-basis’\u003e ]; 这个属性可以把上面讲的三个属性合在一起写。 如果写flex：none;表示0 0 auto 如果写flex：auto;表示1 1 auto 如果只写一个值flex:1/1px;没有单位的表示grow，有单位的表示basis 如果写两个值flex:（1 1）（1 1px）;前者表示grow和shrink，后者表示grow和basis 如果写三个值就是grow shrink basis拉！ 好啦，整理结束！ ","date":"2017-09-14","objectID":"/css3%E9%87%8C%E7%9A%84flexbox%E5%B8%83%E5%B1%80/:0:0","tags":["CSS3"],"title":"CSS3里的flexbox布局","uri":"/css3%E9%87%8C%E7%9A%84flexbox%E5%B8%83%E5%B1%80/"},{"categories":["http/浏览器"],"content":" 自学了5个月，我最近才听说cookie和session….之前做验证码接触了session,现在整理一下： ","date":"2017-09-02","objectID":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/:0:0","tags":["cookie和session"],"title":"关于cookie和session的区别以及在PHP中的用法","uri":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/"},{"categories":["http/浏览器"],"content":"二者定义： cookie：是服务器发送到客户端的一串文本数据，由客户端保存，每次请求时都会发送cookie，用于保持会话期间持久数据传递； session：session在服务器端，是通过cookie实现的，在发给浏览器的cookie中有唯一标识SESSONID,用于记录不同的用户的状态； ","date":"2017-09-02","objectID":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/:1:0","tags":["cookie和session"],"title":"关于cookie和session的区别以及在PHP中的用法","uri":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/"},{"categories":["http/浏览器"],"content":"整个过程是这样的： 客户端向服务器发送请求后，服务器会在响应头中返回cookie信息，其中包含唯一标识SESSIOND,客户端收到后就会存储起来，之后客户端的每次请求都会包含cookie信息，session会找到cookie中的sessionid，并且根据它找到对应的用户，及其存储在服务器的数据。 ","date":"2017-09-02","objectID":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/:2:0","tags":["cookie和session"],"title":"关于cookie和session的区别以及在PHP中的用法","uri":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/"},{"categories":["http/浏览器"],"content":"二者区别： cookie存储在浏览器中，session存储在服务器中； cookie并不安全，别人可以篡改你的cookie信息,单个cookie存储数据不超过4k,一个浏览器最多存储20-50个cookie； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。 注意：浏览器是可以禁用cookie的，与此同时session也会失效，这是我们还有两种方法 URL重写，把SESSIONID加到URL后，即’sid=XXX’的形式； 表单隐藏：在HTML加一个隐藏表单如下： \u003cform name=\"testform\" action=\"/xxx\"\u003e \u003cinput type=\"hidden\" name=\"jsessionid\" value=\"ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764\"\u003e \u003cinput type=\"text\"\u003e \u003c/form\u003e ","date":"2017-09-02","objectID":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/:3:0","tags":["cookie和session"],"title":"关于cookie和session的区别以及在PHP中的用法","uri":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/"},{"categories":["http/浏览器"],"content":"在PHP中cookie用法 setcookie（名称，值，失效时间，域，路径，安全标志） 第一个和第二个参数是必填，其他都是可选 一般我们都这样设置几个参数 setcookie('name','lili',time()+3600) //创建或更新cookie setcookie（'name','',time()-3600） //删除cookie，值设置为空，时间为负数 setcookie（'name',null） //这样删除也可以 //用$_COOKIE['name']读取，在读取时，先要判断是否为空值 if(isset($_COOKIE['name'])){ $Name=$_COOKIE['name']; } //或者这样 If(!empty($_COOKIE['name'])){ $Name=$_COOKIE['name']; } ","date":"2017-09-02","objectID":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/:4:0","tags":["cookie和session"],"title":"关于cookie和session的区别以及在PHP中的用法","uri":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/"},{"categories":["http/浏览器"],"content":"在PHP中session用法 在使用session前我们都要初始化session_start()（他会创建一个唯一SESSIONID）,在这之前不能有输出语句。 $_SESSON['name']='lili' //赋值 $Name=$_SESSION['name'] //读取值 session_unset['name'] //删除值（逐个） $_SESSION=array(); //整个删除 session_destroy(); //最后整个摧毁 session session_is_registered(); // 检查变量是否被登记为会话变量,如果是返回TRUE session_name(); //设置或获取当前session的名称 session_set_cookie_params(): //设置session的生存期，必须在session_start()之前调用; session_save_path() ; //设置session保存路径，必须在session_start()之前调用; ","date":"2017-09-02","objectID":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/:5:0","tags":["cookie和session"],"title":"关于cookie和session的区别以及在PHP中的用法","uri":"/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8php%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/"},{"categories":["http/浏览器"],"content":" http协议全称超文本传输协议，它是无连接无状态的，默认端口为80，学习前端呢，我们也需要对其请求到响应也要有一个熟悉过程。 无连接：就是每次连接只能处理一次请求； 无状态：就是没有记忆能力，每次连接都会重复传数据，上次已经请求了的话。 http协议与服务器的交互主要有4种方式GET,POST,PUT,DLETE,分别对应着查询、修改、增添、删除操作。 ","date":"2017-09-02","objectID":"/%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/:0:0","tags":["http"],"title":"理解http协议","uri":"/%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/"},{"categories":["http/浏览器"],"content":"http请求由三部分组成，状态行、请求头、请求正文 我们以下图post方式为例： 状态行：就是第一行，以空格隔开第一个是请求方式，第二个是请求路径，第三个是http协议版本； 请求头：就是第二行一直到最后，这里是一些浏览器环境的信息，比如浏览器所支持的语言，请求正文的长度等； 请求正文：这里没有，主要是放一些向服务器传送的数据，注意它是以空格和请求头隔开的。 http响应由三部分组成，状态行、响应头、响应正文 状态行：和请求的状态行类似，第一个表示http协议版本，第二个是状态码200 OK表示客户端请求成功； 状态码是由三位组成的： 态码一般由3位构成： 1xx : 表示请求已经接受了，继续处理。 2xx : 表示请求已经处理掉了。 3xx : 重定向。 4xx : 一般表示客户端有错误，请求无法实现。 5xx : 一般为服务器端的错误。 比如常见的状态码： 200 OK 客户端请求成功。 301 Moved Permanently 请求永久重定向。 302 Moved Temporarily 请求临时重定向。 304 Not Modified 文件未修改，可以直接使用缓存的文件。 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权，无法访问。 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。 404 Not Found 请求的资源不存在，比如输入了错误的URL。 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 响应头：和请求头差不多，包含一些服务器有用的信息， 例如服务器的类型，日期，长度等； 响应正文：这里是服务器返回的HTML文件。 现在当我们在地址栏输入badu.com后，我们就能知道发生了什么事了。 输入域名后，浏览器会找DNS解析域名（当然他先会转化成这种格式http://www.baidu.com/） 首先他会在浏览器自身DNS缓存里找； 找不到就回去操作系统（os）DNS缓存里找； 找不到会到系统host文件里找，看对应的域名有没有映射IP； 最后会到域名服务器找，找到后与服务器进行TCP三次握手进行连接； 连接后，进行http请求； 服务器收到请求后会返回状态行和响应信息（html）; 7浏览器开始解析HTML构建DOM树，如果没有后续请求，浏览器会向服务器发起TCP断开（四次挥手）。 ","date":"2017-09-02","objectID":"/%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/:1:0","tags":["http"],"title":"理解http协议","uri":"/%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/"},{"categories":["JavaScript"],"content":" 一般在我们浏览器端负责输入数据格式的验证，在服务器端利用ajax技术查询验证输入数据是否重复 ","date":"2017-08-25","objectID":"/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81ajax-jquery-validate-phpgd2/:0:0","tags":["jquery"],"title":"表单验证（ajax+jQuery Validate+PHPgd2）","uri":"/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81ajax-jquery-validate-phpgd2/"},{"categories":["JavaScript"],"content":"一、浏览器端的验证我们可以用jQuery Validate这个插件 首先引入插件： \u003cscript src='libs/jquery-1.11.1.min.js'\u003e\u003c/script\u003e/ //jquery插件 \u003cscript src='libs/jquery.validate.min.js'\u003e\u003c/script\u003e //jQuery validate插件 \u003cscript src='libs/messages_zh.min.js'\u003e\u003c/script\u003e //中文提示信息插件 具体使用看如下例子： js部分 $(function(){ //指定要验证的表单 $('#myform').validate({ //这里是验证通过要书写回调函数 submitHandler:function(form){ //提交表单方式之一 form.submit(); } //这里定义规则 rules:{ username:{ requried:true, minlength:2 } } //这里写提示信息，如果不写，就会使用默认 messages:{ username:{ required:\"请输入用户名！\", minlength:\"长度不少于2位！\" } } }) }) 更多的其他的指令规则：规则 描述 required:true 必须输入的字段。 remote:“check.php” 使用 ajax 方法调用 check.php 验证输入值。 email:true 必须输入正确格式的电子邮件。 url:true 必须输入正确格式的网址。 date:true 必须输入正确格式的日期。日期校验 ie6 出错，慎用。 dateISO:true 必须输入正确格式的日期（ISO），例如：2009-06-23，1998/01/22。只验证格式，不验证有效性。 number:true 必须输入合法的数字（负数，小数）。 digits:true 必须输入整数。 creditcard: 必须输入合法的信用卡号。 equalTo:\"#field\" 输入值必须和 #field 相同。 accept: 输入拥有合法后缀名的字符串（上传文件的后缀）。 maxlength:5 输入长度最多是 5 的字符串（汉字算一个字符）。 minlength:10 输入长度最小是 10 的字符串（汉字算一个字符）。 rangelength:[5,10] 输入长度必须介于 5 和 10 之间的字符串（汉字算一个字符）。 range:[5,10] 输入值必须介于 5 和 10 之间。 max:5 输入值不能大于 5。 min:10 输入值不能小于 10。 小提示：可以使用label.error自定义错误信息提示样式; ","date":"2017-08-25","objectID":"/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81ajax-jquery-validate-phpgd2/:1:0","tags":["jquery"],"title":"表单验证（ajax+jQuery Validate+PHPgd2）","uri":"/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81ajax-jquery-validate-phpgd2/"},{"categories":["JavaScript"],"content":"二、关于验证码 要用到PHPgd库里面提供的一些api,使用前注意开启PHPgd2 具体示例： // 创建画布 $img=imagecreate(100, 35); // 给画布分配背景颜色，mt_rand()就是返回随机整数 $bgcolor=imagecolorallocate($img, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255)); // 添加干扰线，用for循环，随机画三条 for ($i=0; $i \u003c 3; $i++) { // 为干扰线添加随机颜色 $linecolor=imagecolorallocate($img,mt_rand(0,255), mt_rand(0,255),mt_rand(0,255)); // 开始画干扰线 imageline($img,mt_rand(0,100),mt_rand(0,35),mt_rand(0,100),mt_rand(0,35),$linecolor); } // 添加干扰点,for循环，随机添加25个点 for ($i=0; $i \u003c25 ; $i++) { //为点添加随机颜色 $diancolor=imagecolorallocate($img,mt_rand(0,255), mt_rand(0,255),mt_rand(0,255)); // 开始画点 imagesetpixel($img,mt_rand(0,100),mt_rand(0,35),$diancolor); } // 准备一个字符串 $rand_str='qwertyuiopasdfghjklzxcvbnm1234567890'; // 准备一个空数组 $str_arr=array(); // 循环四次返回4个随机字母或数字 for ($i=0; $i \u003c4 ; $i++) { // 随机取从0到字符串长度的下标 $pos=mt_rand(0,strlen($rand_str)-1); // 一一放到数组里 $str_arr[]=$rand_str[$pos]; } // 开启sesson,把这四个数据放进session里 session_start(); $_SESSION['info']=$str_arr; // 准备绘制，可以用imagestring(不支持中文)或者imagettftext(支持中文但需要下载字体) //用imagesttftext绘制 $x_start=100/5; // foreach用于遍历输出数组，不知道循环次数 foreach ($str_arr as $key) { $fontcolor = imagecolorallocate($img, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255)); imagettftext($img, 20, mt_rand(-15,15), $x_start, 50/2, $fontcolor, \"C:/Windows/Fonts/Verdana.TTF\", $key); $x_start +=20; //遍历后单个字符沿X轴 +20 } // 填充 imagefill($img,0,0,$imgcolor); ob_clean(); // 输出图像格式 header('content-type:image/jpeg'); // 输出图像 imagejpeg($img); // 摧毁图像 imagedestroy($img); 我们在HTML中创建一个img,src属性指向这个PHP页面即可显示出来，如：src=data.php 点击图片刷新属性： 验证验证码是否正确，利用ajax传送到后端，后端如下判断： \u003c?php header('content-type:text/html;charset= utf-8'); // 接受验证码 $yzm=$_POST['num']; session_start(); // 把数组里的数据都取出来 $data=implode('',$_SESSION['info']); if($yzm==$data){ echo'1'; } ?\u003e 注意：我也不知道为什么，一开始老是验证不了，最后是需要再单独建一个PHP，再在里面写上验证代码就好了。 ","date":"2017-08-25","objectID":"/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81ajax-jquery-validate-phpgd2/:2:0","tags":["jquery"],"title":"表单验证（ajax+jQuery Validate+PHPgd2）","uri":"/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81ajax-jquery-validate-phpgd2/"},{"categories":["angular"],"content":" 首先了解一下跨域：跨域就是从一个网站去请求另一个网站中的内容。 要想实现跨域，现在主流的做法是用jsonp。 ","date":"2017-08-24","objectID":"/angular-js-%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/:0:0","tags":["angular js"],"title":"angular  js 获取天气预报","uri":"/angular-js-%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/"},{"categories":["angular"],"content":"一、jsonp的原理 我们发现HTML标签是可以请求外网的内容的， 比如img的src设置为外网的图片地址，是可以读取到的，那么我们可以新建一个script标签，设置它的src属性就是外网的地址，那么我们就能读取到外网的内容，jsonp会用到ajax方法，但是其实它跟ajax是没有关系的，jsonp是get请求。 ","date":"2017-08-24","objectID":"/angular-js-%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/:1:0","tags":["angular js"],"title":"angular  js 获取天气预报","uri":"/angular-js-%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/"},{"categories":["angular"],"content":"二、去百度拿天气数据 百度车联网API， 里面百度给我们提供了一个url: http://api.map.baidu.com/telematics/v3/weather?location=北京\u0026output=json\u0026ak=E4805d16520de693a3fe707cdc962045 其中ak指的是开发者密钥，这个我们需要注册一下百度账号，再点击获取密钥就可以了。 ","date":"2017-08-24","objectID":"/angular-js-%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/:2:0","tags":["angular js"],"title":"angular  js 获取天气预报","uri":"/angular-js-%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/"},{"categories":["angular"],"content":"三、在angular js 中有很多的内建服务，比如$http、$log、$location等等， 在我们需要用他们的时候，就要在控制器内传入他们，如下： weather.controller('WeatherController',['$scope','$http','$log',function($scope,$http,$log){ } 这里传入三个参数，$scope,$http,$log，告诉angular js我们需要他们，angularjs 就会以参数的形式传进来供我们使用，这里的$http就是供我们向服务端发送异步请求的，而$log里提供了一系列的打印方法。 完整代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eweather\u003c/title\u003e \u003c/head\u003e \u003cbody ng-app='weather'\u003e \u003cdiv ng-controller='WeatherController'\u003e \u003cbutton ng-click='get()'\u003e获取南京的天气\u003c/button\u003e \u003ctable\u003e \u003c!-- 视图 --\u003e \u003ctr ng-repeat=\"item in weatherData\"\u003e \u003ctd\u003e{ {item.date}}\u003c/td\u003e \u003ctd\u003e\u003cimg ng-src=\"{ {item.dayPictureUrl}}\" alt=\"\"\u003e\u003c/td\u003e \u003ctd\u003e\u003cimg ng-src=\"{ {item.nightPictureUrl}}\" alt=\"\"\u003e\u003c/td\u003e \u003ctd\u003e{ {item.temperature}}\u003c/td\u003e \u003ctd\u003e{ {item.weather}}\u003c/td\u003e \u003ctd\u003e{ {item.wind}}\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/div\u003e \u003cscript src='libs/angular.min.js'\u003e\u003c/script\u003e \u003cscript\u003e // 定义模板 var weather=angular.module('weather',[]); // 定义控制器 weather.controller('WeatherController',['$scope','$http','$log',function($scope,$http,$log){ $scope.get=function(){ $http({ url:'http://api.map.baidu.com/telematics/v3/weather', method:'jsonp', // params会自动的帮我们把数据拼接到URL上 params:{ location:'南京', output:'json', ak:'0A5bc3c4fb543c8f9bc54b77bc155724', //JSON_CALLBACK只是一个占位符，必须写。 callback:'JSON_CALLBACK' } }) .success(function(data){ $log.log(data); $scope.weatherData=data.results[0].weather_data; }); } }]); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2017-08-24","objectID":"/angular-js-%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/:3:0","tags":["angular js"],"title":"angular  js 获取天气预报","uri":"/angular-js-%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/"},{"categories":["JavaScript"],"content":" ajax是一种在不刷新页面的情况下，局部更新数据的一种技术，XMLHTTPRequest对象是ajax的基础。 使用ajax有以下4个步骤： （1）创建XMLHTTPRequest对象 所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 兼容性写法如下： var xmlhttp; if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else { // code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } （2）向服务器发送请求 这里我们使用open()和send()方法 open(method，url,flag),open()方法中有三个参数： method：请求方式，有get和post两种； url:要请求页面的地址，相对地址或绝对地址 flag：true是异步，false是同步 注意点： get和post的比较：get传输数据小且不安全，post传输数据大且安全； 使用post方式时，注意添加http请求头协议； send(string),send()中有一个参数，当使用GET方式请求时，里面没有参数，使用post方式时，里面写上传输的数据； 示例get请求： xmlhttp.open('get','123.php',true); xmlhttp.send(); 示例post请求： xmlhttp.open('post','123.php','true'); //添加http请求头信息 xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); xmlhttp.send(\"name=lili\u0026amp;age=10\"); 服务器的响应 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据。 onreadystatechange 事件 当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性： onreadystatechange属性，每当readyState属性变化时就会调用该函数； readyState属性，它有四种状态变化： 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status属性 200: “OK” 404: 未找到页面 所以当 readyState 等于 4 且状态为 200 时，表示响应已就绪： 示例： xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 \u0026amp;\u0026amp; xmlhttp.status==200) { document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; } } Query中的ajax 在jQuery中我们有$.get()、$.post()、$.ajax()方法来向服务器发送数据 $.get() $.get(url,data,success(),datatype) url:必填； data：可选，规定请求的同时发送的数据； success()：可选，请求成功时运行的函数； datatype：可选，服务器响应的数据类型，JQuery会只能判断； $.post()方法差不多 url:必填； data：可选，规定请求的同时发送的数据； success()：可选，请求成功时运行的函数； datatype：可选，服务器响应的数据类型，JQuery会只能判断； $.ajax()方法可以替换上面两种方法，定制自由度更高,以下是常用属性； $.ajax({ url:‘01.php’,//请求地址 data:‘name=fox\u0026age=18’,//发送的数据 type:‘GET’,//请求的方式 success:function (argument) {},// 请求成功执行的方法 beforeSend:function (argument) {},// 在发送请求之前调用,可以做一些验证之类的处理 error:function (argument) {console.log(argument);},//请求失败调用 }) ","date":"2017-08-24","objectID":"/ajax%E5%A4%8D%E4%B9%A0/:0:0","tags":["ajax复习"],"title":"ajax复习","uri":"/ajax%E5%A4%8D%E4%B9%A0/"},{"categories":["angular"],"content":" 一个备忘录小练习，可以写入计划和删除计划。 进一步了解了一些指令的使用： ng-repeat='(key,item) in items': 用于循环输出，加在需要循环输出的元素上,items是控制器上变量名字，item是变量数组中单个元素的别名，key表示索引值，从0开始。 ng-model=‘text’ 用于向控制器传送数据，体现双向绑定数据特性，注意表单要加上ng-submit=‘add()'; ng-click=‘add()’ 点击事件，在控制器上可以书写对应的函数; splice(index，0，items) 删除或插入数组，index表示从第几位删除或插入，0表示几个元素，items可选表示数组； ","date":"2017-08-22","objectID":"/%E5%88%9D%E8%AF%86angular-js-%E5%A4%87%E5%BF%98%E5%BD%95%E7%BB%83%E4%B9%A0/:0:0","tags":["angular js"],"title":"初识angular js ,备忘录练习","uri":"/%E5%88%9D%E8%AF%86angular-js-%E5%A4%87%E5%BF%98%E5%BD%95%E7%BB%83%E4%B9%A0/"},{"categories":["angular"],"content":" 看到了angular js， angular js是一款MVC前端框架，以数据和逻辑作为驱动核心，有很多特性：模块化，双向数据绑定，语义化标签等，与之类似的还有VUE，REACT等框架。 MVC是一种开发模式，由模型（Model）、视图（View）、控制器（Controller）3部分构成。 基本用法： 首先script标签引入angular js 框架； 其次定义模板，第一个参数为模板名称，第二个参数为一个空数组,表示依赖的其他模块； 然后定义控制器，第一个参数为控制器名称，第二个参数除最后一个是函数外，其他都是字符串，表明此控制器的依赖关系， 控制器里书写逻辑数据； 最后绑定模板，绑定控制器； 具体示例代码如下： \u003c!-- 绑定模块 --\u003e \u003cbody ng-app='Tabs'\u003e \u003c!-- 绑定控制器 --\u003e \u003cdiv class=\"container\" ng-controller='TabController'\u003e \u003cul\u003e \u003cli ng-class=\"{current:type=='first'}\" ng-click='switch(\"first\")'\u003etab1\u003c/li\u003e \u003cli ng-class=\"{current:type=='second'}\" ng-click='switch(\"second\")'\u003etab2\u003c/li\u003e \u003cli ng-class=\"{current:type=='third'}\" ng-click='switch(\"third\")'\u003etab3\u003c/li\u003e \u003c/ul\u003e \u003cdiv ng-switch on='type'\u003e \u003cdiv ng-switch-when='first'\u003e这里是内容一哦\u003c/div\u003e \u003cdiv ng-switch-when='second'\u003e这里是内容二哦\u003c/div\u003e \u003cdiv ng-switch-when='third'\u003e这里是内容三哦\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- 引入angularjs 框架 --\u003e \u003cscript src=\"../libs/angular.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e // 定义模板 var Tabs = angular.module('Tabs',[]); // 定有控制器 Tabs.controller('TabController',['$scope',function($scope){ // 这个$scope就是空的对象，指的就是Model $scope.type='first'; $scope.switch = function(type){ $scope.type=type; } }]); \u003c/script\u003e \u003c/body\u003e ng-bind是angular js中的指令，和我们HTML标签中src一样，只不过换个叫法，angular js中还有其他常用的指令，比如ng-class,ng-switc,ng-show等等，更多指令后续再来复习。 掌握好基础用法后，我们常见的简单的Tab栏切换，也可以用这个来做，具体demo如下。 ","date":"2017-08-22","objectID":"/%E5%88%9D%E8%AF%86angular-jstab%E6%A0%8F%E5%88%87%E6%8D%A2%E7%BB%83%E4%B9%A0/:0:0","tags":["angular js"],"title":"初识angular js，tab栏切换练习","uri":"/%E5%88%9D%E8%AF%86angular-jstab%E6%A0%8F%E5%88%87%E6%8D%A2%E7%BB%83%E4%B9%A0/"},{"categories":["工具"],"content":" 从学习前端开始就听说过Git，无奈初期并不需要了解，但是在以后的学习或工作中这是必须会的一项技能，这几天也看了一些资料，整理一下 一、什么是Git？ Git是分布式版本控制系统，版本控制系统大致分为三类： 本地版本控制系统：顾名思义，只能在本地进行修订存储的系统，缺点是不能多人协同开发； 集中式版本控制系统：有一个中央服务器，文件的版本信息，修订及其存储都在这上面，但是太依赖网络，一旦网络瘫痪，数据容易丢失； 分布式版本控制系统：每个人本地都有一个版本控制系统，会有一个共享服务器，弥补了前面两种系统的缺陷，是现在使用是最多的版本控制系统，其中最有代表的就是Git。 二Git的安装 https://git-scm.com/downloads 三、Git的使用原理 Git是使用命令行方式运行的； Git有三个工作区域： 工作目录：在这个区域你可以对你的项目进行开发修改； 暂存区域：开发或修改完成后可以将项目放在这里，之后一并提交； 仓库区域：这里会永久存储暂存区域上传的数据，这是Git最重要的部分，我们还原的数据时就是存储在这里的。 四、Git的使用 配置用户及其邮箱一边我们记录开发者的信息： 找打我们开发项目的根目录： 右击Git Bash here，进入命令行窗口模式： 输入：git config –global user.name ‘你的名字’，git config –global user.email ‘你的邮箱’ 初始化仓库： git init,这时我们根文件夹会出现一个隐藏文件夹.git 接下来我们就可以在工作目录中开发项目了，这里我在index.html中修改了一些内容，可以使用命令git status查看文件状态 可以看到这些在工作区的内容是红色的 使用命令git add 文件名（或者-A表示所有），将文件放到暂存区域内，再来查看状态，我们发现文件变成了绿色 如果我们想把暂存区的文件再返回到工作区，可以使用git checkout 文件名 之后我们觉得所有文件都没问题后，就可以提交了git commit -m ‘备注信息’,并且可以git log 来查看提交历史 时光倒流：我们可以使用 git reset –hard 字符串（每一次提交历史后面的字符串），就返回到那个状态。 Git的分支：当我们第一次提交时，就已经默认创建了一个主分支master ，当我们开发不止一个项目或功能时，不可能三七二一都提交到这个分支上吧，所以我们会创建对应的功能分支或项目分支，主分支我们一般会来发布稳定版本，我们会创建一个developer平行分支，在这上面针对不同的功能再创建feature分支，开发完成后都提交到developer这个分支上，所有功能开发完成后，我们还需要创建一个发行分支release供测试使用，最后才发布稳定版本到主分支上。 git branch lazaer //创建分支 git checkout lazaer //切换分支 git merge ‘分支名称’ //合并分支 git branch -d lazaer //删除分支 五、共享仓库 第四点主要讲了在本地如何使用Git，为了协同开发，和其他人共享代码，我们需要建一个共享仓库 Git要求共享仓库是一个以.git结尾的目录。 mkdir repo.git 创建以.git结尾目录 cd repo.git 进入这个目录 git init –bare 初始化一个共享仓库，也叫裸仓库 注意选项–bare 这样就建好了一个空的仓库 将本地仓库的内容提交到共享仓库 git push 路径 master（要同步的分支） 将共享仓库的内容同步到本地仓库 git pull 路径 master（要同步的分支） 六、关于GitHub和Gitlab 其实为了更好的管理我们的仓库，一些第三方机构开发出了Web版仓库管理程序，通过Web界面形式管理仓库。 这里主要介绍下GitHub，Gitlab差不多，主要区别就是Gitlab的私人仓库是免费，一般企业的项目会部署在这上面，而GitHub是要收费的。 首先自行注册一个GitHub账号； 创建一个仓库，随后进入到这个界面 关于ssh我们要知道他是一个加密协议，用于连接两台计算机的，采用非对称加密，我们需要在本地生成两个密钥，一个公钥一个私钥，将公钥里的内容复制到GitHub上，这样我们每次从GitHub上存储或拿出数据时就不需要密码了。 在命令行中敲下如下命令： ssh-keygen -t rsa, 一路回车就会在当前用户生成一个.ssh的文件夹将id-rsa.pub里的内容复制到个人中心设置下，ssh密钥选项里 这样我们向GitHub上push或pull就不需要密码了 将本地仓库的内容提交到共享仓库 git push 路径 master（要同步的分支）这里的路径就是ssh地址 将共享仓库的内容同步到本地仓库 git pull 路径 master（要同步的分支）这里的路径就是ssh地址 这里的例子是push,pull也是一样的 七、最后关于Git的命令汇总 git config配置本地仓库 常用git config –global user.name、git config –global user.email git config –list查看配置详情 git init 初始一个仓库，添加–bare可以初始化一个共享（裸）仓库 git status 可以查看当前仓库的状态 git add“文件” 将工作区中的文件添加到暂存区中，其中file可是一个单独的文件，也可以是一个目录、“*”、-A git commit -m ‘备注信息’ 将暂存区的文件，提交到本地仓库 git log 可以查看本地仓库的提交历史 git branch查看分支 git branch“分支名称” 创建一个新的分支 git checkout“分支名称” 切换分支 git checkout -b deeveloper 创健并切到developer分支 git merge“分支名称” 合并分支 git branch -d “分支名称” 删除分支 git clone “仓库地址”获取已有仓库的副本 git push origin “本地分支名称:远程分支名称”将本地分支推送至远程仓库， git push origin hotfix（通常的写法）相当于 git push origin hotfix:hotfix git push origin hotfix:newfeature 本地仓库分支名称和远程仓库分支名称一样的情况下可以简写成一个，即git push “仓库地址” “分支名称”，如果远程仓库没有对应分支，将会自动创建 git remote add “主机名称” “远程仓库地址”添加远程主机，即给远程主机起个别名，方便使用 git remote 可以查看已添加的远程主机 git remote show “主机名称”可以查看远程主机的信息 ","date":"2017-08-20","objectID":"/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["Git"],"title":"关于Git的使用","uri":"/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["JavaScript"],"content":"一、函数模式 这个我们再熟悉不过了。 function foo(){ console.log(this); } foo()；//这里函数名调用，就是函数模式 注意：这里的this指的是window全局对象； 二、方法模式 函数放在对象内，是对象的一个属性，我们调用函数，这就是方法模式。 var obj={ foo:function(){ console.log(this); } } obj.foo(); 注意：这里的this指的是调用这个方法的对象。 三、构造函数模式 function Person(){ console.log(this); } var obj =new Person(); 注意：这里的this指的是new创建出来的对象。 四、上下文模式 这里我们用apply()和call()来自定义this的指向； 这两个方法在Function的原型中，所以任何函数都可以使用它们； 这里简单介绍一下这两个方法： call和apply的两个参数 1.第一个参数都是要把this修改成的对象 2.当函数需要参数的时候，那么apply是用数组进行参数的传递 3.而call是使用单个的参数进行传递 call和apply使用 1.call用于确定了函数的形参有多少个的时候使用 2.apply用于函数的形参个数不确定的情况 比如： function person(){ console.log('hi'); } function student(){ person.call(this); } var stu=student(); stu(); 这里的this指的是student，意思就是student这个对象来执行person里面的内容； 这样函数studengt里没有方法，却打印出了person里的语句，这里用apply或call一样的。 ","date":"2017-08-09","objectID":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%BA%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F/:0:0","tags":["javascript基础知识复习"],"title":"JavaScript基础知识复习（五）函数的四种调用模式","uri":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%BA%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["JavaScript"],"content":"递归 递归概念：在函数内调用函数自己，就是递归。 注意：递归要有结束条件，没有递归结束条件的递归，就是死递归。 使用递归的方法：化归思想。化归思想是将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。 例子：求1-100的和 利用划归思想：var sum=foo(100); 1.求foo（100）即求foo（99）+100； 2.求foo（99），即求foo（98）+99； 3.求foo（98），即求foo（97）+98； … 最后求foo（1），就是1;//这就是约束条件 最后利用递归，函数就是： function foo( n ) { if ( n == 1 ) return 1; return n + foo( n - 1 ); } 利用递归可以解决很多问题，比如算出阶乘，算出斐波那契数列等； 二、闭包 闭包概念：有权访问另一个函数作用域内变量的函数都是闭包。 闭包的原理是作用域访问原则，及上级作用域不能访问下级作用域。 闭包要解决的问题： a)闭包内的数据不允许外界访问 b)间接访问该数据 我们知道js中函数就是一个小黑屋，外部是不能访问内部变量的，但是内部变量是可以访问外部变量的，所以为能从外部访问，利用作用域访问原则，在函数里面再建一个函数，这个内部函数在外部函数内部可以直接访问外部函数的所有变量，我们再在全局里获取这个内部函数的返回值，就可以实现对外部函数里变量的读取和修改。 读取： function foo() { var num = Math.random(); function func() { return num; } return func; } var f = foo(); var res1 = f(); return只能用一次，那如何读取多个数据呢： function foo () { var num1 = Math.random(); var num2 = Math.random(); //可以将多个函数包含在一个对象内进行返回，这样就能在函数外部操作当前函数内的多个变量 return { num1: function () { return num1; }, num2: function () { return num2; } } } var f = foo(); console.log(f.num1()); console.log(f.num2()); 使用闭包修改数据： function foo() { var name = \"高金彪\"; var gender = \"female\"; return { getName:function () { return name; }, setName:function(value){ name = value; return name; }, setGender:function(value){ gender = value; return gender; }, getGender:function(){ return gender; } }; } var obj = foo(); console.log(obj.getGender()); console.log(obj.setGender(\"雄\")); 闭包的作用第一点就是上面讲了，他可以访问函数内部的变量并修改，第二点可以在函数内部创建私有空间，设置安全措施、校验之类的操作，比如： function foo(){ var name = \"lili\"; return { getName: function () { return name; }, setName: function (value) { //在这里写一些逻辑验证操作 if(value==0){ throw \"名字不能为0！！\"; return name; } else{ name = value; return name; } } } } 最后再总结下，这里介绍了闭包的概念，基本使用，和基本作用，要加深闭包的理解还需要做很多练习。 ","date":"2017-08-09","objectID":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E5%9B%9B%E9%80%92%E5%BD%92%E4%B8%8E%E9%97%AD%E5%8C%85/:1:0","tags":["javascript基础知识复习"],"title":"javascript基础知识复习（四）递归与闭包","uri":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E5%9B%9B%E9%80%92%E5%BD%92%E4%B8%8E%E9%97%AD%E5%8C%85/"},{"categories":["JavaScript"],"content":"一、作用域 ","date":"2017-08-07","objectID":"/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/:0:0","tags":["js"],"title":"js中的作用域及变量提升","uri":"/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"},{"categories":["JavaScript"],"content":"作用域有：块级作用域和词法作用域； 块级作用域：使用{}包裹起来的，里面的变量外面是不可以访问的，js没有块级作用域，js里外面是可以访问{}里的变量的; 词法作用域：词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是所谓词法作用域.js中有词法作用域。 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 ","date":"2017-08-07","objectID":"/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/:0:1","tags":["js"],"title":"js中的作用域及变量提升","uri":"/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"},{"categories":["JavaScript"],"content":"作用域链 概念：只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。 凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 如下代码: function f1() { function f2() { } } var num = 456; function f3() { function f4() { } } 它的作用域链图就是： 绘制作用域链的步骤: 看整个全局是一条链, 即顶级链, 记为 0 级链 看全局作用域中, 有什么成员声明, 就以方格的形式绘制到 0 级练上 再找函数, 只有函数可以限制作用域, 因此从函数中引入新链, 标记为 1 级链 然后在每一个 1 级链中再次往复刚才的行为 变量的访问规则 首先看变量在第几条链上, 在该链上看是否有变量的定义与赋值, 如果有直接使用 如果没有到上一级链上找( n - 1 级链 ), 如果有直接用, 停止继续查找. 如果还没有再次往上刚找… 直到全局链( 0 级 ), 还没有就是 is not defined 注意,同级的链不可混合查找 二、变量提升 1.js代码的执行分为两个步骤： 预解析 JavaScript代码在预解析阶段，会对以var声明的变量名，和function开头的语句块，进行提升操作 然后再执行 第一个阶段就是变量提升的过程，解释器会先找到var已经声明的变量和function开头的语句，并把他们提升到代码开头，然后再执行。 例子1： func(); function func(){ alert(\"Funciton has been called\"); } // 提升后： function func(){ alert(\"Funciton has been called\"); } func(); 例子2： alert(a); var a = 1; 提升后： var a; //这里是声明 alert(a);//变量声明之后并未有初始化和赋值操作，所以这里是 undefined a = 1; 2.复杂点的情况 （1）函数同名：后面的会覆盖前面的 比如： func1(); function func1(){ console.log('This is func1'); } func1(); function func1(){ console.log('This is last func1'); } // 提升后： function func1(){ console.log('This is func1'); } function func1(){ console.log('This is last func1'); } func1(); func1(); 提升后，因为后面会覆盖前面的，所以结果都为：This is last func1。 (2)变量和函数名同名 当出现变量声明和函数同名的时候，只会对函数声明进行提升，变量会被忽略。 比如： alert(foo); function foo(){} var foo = 2; // 提升后： function foo(){}; alert(foo); foo = 2; （3）声明提升并不是将所有的声明都提升到window对象下面，提升原则是提升到变量运行的环境(作用域)中去。 比如： function showMsg() { var msg = 'This is message'; } alert(msg); // msg未定义 // 提升后： function showMsg() { var msg; msg = 'This is message'; } alert(msg); // msg未定义 （4）提升是分段的，其实就分script标签的。两个script标签之间是分开的。 （5）函数表达式不提升 比如： function showMsg() func(); var func = function(){ alert(\"我被提升了\"); }; 这里会报错：func is not a function； ","date":"2017-08-07","objectID":"/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/:0:2","tags":["js"],"title":"js中的作用域及变量提升","uri":"/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"},{"categories":["JavaScript"],"content":"js中共有6种继承 一、原型链 function SuperType(){ this.prototype=true; } SuperType.prototype.getSuperValue=function(){ return this.property } function SubType(){ this.subPrototy=false; } //继承了SuperType SubType.prototype=new SuperType(); SubType.prototype.getSubValue=function(){ return this.subProperty; } var instance = new SubType(); console,log(instance.getSuperValue);//true console.log(instance.getSubValue);//false 以上代码我们可以看到定义两个构造函数，里面有属性，原型里面有方法，我们让SubType的原型等于SuperType的实例，通过替换了SubType的默认原型对象实现继承，我们可以看到SubType的实例成功调用SuperType里的方法，之后我们又为其手动添加了一个新的方法也是可以调用的。 注意：继承原型后使用字面量添加方法，会使继承无效，因为已经替换了原型，我们在上一篇中介绍原型时已经讲过。 缺点：（1）继承后的原型对应的构造函数它所有的实例都会共享原型中的方法。 （2）继承的子类和父类，子类是不能向父类传参数的。 二、借用构造函数 function SuperType (){ this.colors=['red','blue']; } function SubType(){ //用call或者apply将调用对象换成SuperType实现对SuperType函数的继承 //this指向当前对象 SuperType.call(this); } var o=new SubType(); o.colors.push('black'); console.log(o);//red,blue,black var o1=new SubType(); console.log(o1)//red,blue //利用call()或apply()在子类函数中调用父类函数实现继承，我们可以看到SubType的实例并不共享属性；而且子类也是可以向父类传参的 function SuperType (name){ this.name=name; } function SubType(){ SuperType.call(this，'lili'); this.age=12; } var o=new SubType(); console.log(o.name)//lili console.log(o.age)//12 我们可以看到子类传入参数后，调用父类函数直接赋值给属性name。为了确保父类的属性不会覆盖子类，在调用父类函数后再添加新属性。 缺点：方法都在构造函数中定义，无法函数复用，父类的原型中的方法对于子类也是不可见的。 三、组合继承（原型链和借用构造函数） function SuperType(){ this.name=name; this.colors=\\['red','blue'\\]; } SuperType.prototype.sayName=function(){ alert(this.name); } function SubType(name,age){ SuperType.call(this,name); this.age=age; } SubType.prototype=new SuperType(); SubType.prototype.sayAge=function(){ alert(this.age); } var o=new SubType('lili','23'); o.colors.push('black'); alert(o.color);//red,blue,black alert(o.name);//lili alert(o.age);//23 var o1=new SubType('hi','21'); alert(o1.name);//hi alert(o1.age);//21 我们可以看到父类函数里有两个属性，原型里有一个方法，用原型链继承原型里的方法，这样他们的方法共享，借用构造函数的方法继承了父类函数里的属性，属性不共享，这样每个实例都有自己的属性，和使用相同的方法了。 组合继承避免了原型链和借用构造函数的缺陷，是JavaScript中最常用的继承模式。 四、原型式继承 《JavaScript语言精粹》作者克罗克福德提出了一个方式来实现继承 function object(o){ function F(){} F.prototype = o; return new F(); } var person = { name: \"Nicholas\", friends: \\[\"Shelby\", \"Court\", \"Van\"\\] }; var anotherPerson = object(person); anotherPerson.name = \"Greg\"; console.log(anotherPerson.name);//Greg anotherPerson.friends.push(\"Rob\"); var yetAnotherPerson = object(person); yetAnotherPerson.name = \"Linda\"; console.log(yetAnotherPerson.name);//Linda yetAnotherPerson.friends.push(\"Barbie\"); alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" alert(person.name);//Nicholas，名字不会被修改 我们可以看到object函数中创建了一个临时性的构造函数，将传入的参数等于构造函数的原型，最后返回这个构造函数的实例； 这种原型式继承要求必须要有一个对象作为另一个对象使用的基础。所以我们要先定义一个person对象，之后我们通过函数定义两个实例，并将参数person传入，两个实例成员都有对象person的属性，也可以修改。 ES5中推出了Object.create()规范了原型式继承，方法接受两个参数，第一个就是你准备的参数，第二个（可选）就是为一个新对象定义额外属性的对象。 var person = { name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"] }; var anotherPerson = Object.create(person); anotherPerson.name = \"Greg\"; anotherPerson.friends.push(\"Rob\"); var yetAnotherPerson = Object.create(person); yetAnotherPerson.name = \"Linda\"; yetAnotherPerson.friends.push(\"Barbie\"); alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" Object.create()存在兼容性问题，因此不推荐使用; 解决兼容性问题封装一个自定义函数： function create(obj){ if(Object.create){ return Object.create(obj); }else{ function F() { } F.prototype = obj; return new F(); } } 五、寄生式继承 寄生式继承也是克罗克福德提出的 function createAnother(original){ //object函数不是必须的，任何能返回对象的函数都可以 var clone=object(original); clone.sayHi=function(){ alert('hi'); }; return clone; } var person={ name :'lili'; friends:['jack','van']; }; var anotherPerson=createAnother(person); anotherPerson.sayHi();//hi 寄生式继承的思路跟工厂模式差不多，封装一个函数，函数接受一个参数，参数就是将要作为新对象基础的对象，然后把这对象传给object函数，返回值给clone，再为clone对象添加一个方法，最后返回clone对象。我们可以看到person返回了一个新对象- anotherPerson，新对象不仅有person 的所有属性和方法，还有自己的sayHi方法 缺点：还是函数不能复用的问题; 六、寄生组合式继承 我们之前说过Js的继承用的最多的是第三种组合继承，但是他也有缺点，他会调用两次超类型构造函数（父类函数），第一次调用会创建实例属性name和colors，第二次调用又会如此，这样就覆盖了原来的属性，所以寄生组合式继承是对第一次调用函数的优化，只需创建一个超类型函数的副本即可，这样子类就只调用一次超类型构造函数。 function inheritProt","date":"2017-08-07","objectID":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%B8%89js%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/:0:0","tags":["javascript基础知识复习"],"title":"javascript基础知识复习（三）js中的继承","uri":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%B8%89js%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"},{"categories":["JavaScript"],"content":"一、什么是面向对象？与面向过程又有什么关系？ 面向对象是一种思维方式，解决的重点放在对象上； 面向过程也是一种思维方式，解决的重点放在详细的步骤上； 举个例子：如何去超市买东西？ 从面向对象的角度出发，我们只需要一辆车，还有自己就好了； 从面向过程的角度出发，我们要先拿钱，打开门，开车，进超市； 一句话概括它们之间的关系就是：面向对象是面向过程的封装。 二、js中的对象 js中键值对的集合就是对象。 三、创建对象的几种方法 使用字面量创建对象 var 0={name:'lili',age:'12'}; 这种方法会造成代码冗余，资源浪费； 使用内置构造函数创建对象 var o =new Object(); o.name='lili'; o.age='12'; 创建的代码是空对象，需要为其手动添加对象属性； 工厂模式 function createObj(age,name){ var o=new Object(); o.age=age; o.name=name; o.sayHi=function(){ alert('你好')； }； return o; } var o1=new createObj(){'12','lili'}; 每次调用时都会为这个函数在内存中开辟空间，浪费资源。 自定义构造函数，注意函数名要大写 function MyObj(name,age){ this.name=name; this.age=age; this.sayHi=function(){ console.log('hi'); }; } var myobj=new MyObj('lili','12'); this指的是new出来的对象（即调用者）,和工厂模式差不多，每次调用的时候都会为里面的函数开辟新的内存地址，但是函数的代码功能却是相同的，造成内存资源浪费。 自定义构造函数模式原型模式组合 所以我们需要引入原型概念，将构造函数里的属性和方法分开，将方法放到原型里实现共享。 原型概念：在构造函数创建出来的时候，系统会默认的帮构造函数创建并关联一个神秘的对象，这个对象就是原型，原型默认的是一个空的对象。 原型中的属性和方法，都可以被使用该构造函数创建出来的对象使用。给原型添加属性和方法可以使用构造函数的prototype属性，所以第四种方法可以这样修改： function MyObj(name,age){ this.name=name; this.age=age; } MyObj.prototype.saiHi=function(){ console.log('hi'); } var myobj=new MyObj('lili','12'); myobj.sayHi();//可以调用 这种模式是目前用的最多的,这里是通过构造函数的prototype属性访问原型，也可以对象的__proto__属性访问（主要调试用，不推荐这样使用）。 动态的原型模式 调用函数前先判断是否需要用到原型，如果需要就初始化，不需要的话，这样比第五种就少了初始化这个步骤。用instanceof或者typeof来判断其类型。 function Person (name,age,job){ //属性 this.name=name; this.age=age; this.job=job; //方法 if(typeof this.sayName!='function'){ Person.prototype.sayName=function(){ alert('this.name'); } } } 寄生构造函数模式 function Person(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var friend = new Person(\"Nicholas\", 29, \"Software Engineer\"); friend.sayName(); //\"Nicholas\" 这个模式其实很少用，跟工厂模式差不多，只不过工厂模式没有通过new来生成对象。假设我们需要为对象添加一个额外的方法，可以使用这个模式。因为如果在构造函数中直接添加，会污染其他对象，如果在原型添加，会使所有的实例继承这个方法，没必要，所以我添加的这个方法是跟构造函数和其原型是没有任何关系的。下面我想为对象colors添加一个toPipedString方法就可以用这个模式。 function Person(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var friend = new Person(\"Nicholas\", 29, \"Software Engineer\"); friend.sayName(); //\"Nicholas\" 稳妥构造函数模式 稳妥构造函数采用的是与寄生构造函数模式相似的模式，除了下列两点不同： 创建对象的实例方法不引用this； 不使用new调用构造函数；,可以在一些安全环境下使用这个模式，函数里的私有属性是不可以被修改的。 function Person(name, age, job) { //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 o.name=name; o.age=age; //添加方法 o.sayName = function() { alert(name); } //返回对象 return o; } var friend = Person('Nicholas', 29, 'Software Engineer'); friend.sayName(); // Nicholas Person.name='lili'; console.log(friend.name);//Nicholas,修改不了name console.log(friend.age);//29 五、关于原型其它方面 原型链：每个构造函数都有原型对象，每个对象都会有构造函数，每个构造函数的原型都是一个对象，那么这个原型对象也会有构造函数，那么这个原型对象的构造函数也会有原型对象，这 样就会形成一个链式的结构，称为原型链。 属性搜索原则： 当访问一个对象的成员的时候，会现在自身找有没有,如果找到直接使用， 如果没有找到，则去当前对象的原型对象中去查找，如果找到了直接使用， 如果没有找到，继续找原型对象的原型对象，如果找到了，直接使用， 如果没有找到，则继续向上查找，直到Object.prototype，如果还是没有，就报错。 替换原型对象 function Person(){ } Person.prototype.sayHello = function () { console.log(\"nice to meet you\"); } var p = new Person(); //下面这种格式（使用字面量的方式赋值）就是替换了原型对象 Person.prototype = { }; 原型对象被替换后我们访问原来原型对象中的方法是访问不到的，原型对象中有一个constructor属性，指向构造函数，我们需要手动赋值，保证构造函数—原型—-对象之间这样的三角关系，格式 constructor 函数名 原型继承 原型继承：利用原型中的成员可以被和其相关的对象共享这一特性，可以实现继承这种 实现继承的方式，就叫做原型继承。（原型继承会在js中的继承中讲到） 最后给出原型链的完整图： ","date":"2017-08-06","objectID":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%BA%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["javascript基础知识复习"],"title":"javascript基础知识复习（二）面向对象","uri":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%BA%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaScript"],"content":"一、js的组成 ECMAScript：js的核心，规范了js的语法； DOM：文档对象模型，提供了操作DOM元素的API； BOM：浏览器对象模型，对浏览器对象API的操作； 二、js的数据类型 简单数据类型（也称基本数据类型）：Undefined,Null,Boolean,String,Number; 复杂数据类型：Object，本质由一组无序的名值对组成； 三、js中的部分关键字 in：判断属性是否存在于对象中，for in遍历对象的键； typeOf:判断对象的类型，返回是String类型； delete： 删除对象的属性; 删除未使用var声明的变量; 返回值为boolean 表示是否删除成功; 注意：删除的属性如果不存在，返回true; 删除的如果是原型中的属性，返回true 但是删除不成功; ==和=== (a)==：判断值是否相等； (b)===：判断数据类型和值是否相等； ||和\u0026\u0026； 四、js中的值类型和引用类型 值类型（又叫基本类型）：存储的是数据本身的值，有数值、布尔值、null、 undefined; 值类型赋值：将数据赋值一份给新的变量，两份变量单独存在，互不影响； 引用类型：存储的是数据的地址，而其中的数据会在内存中单独存储； 引用类型赋值：会将存储数据的地址赋值一份，两个地址指向同一个变量，因此， 通过其中一个地址修改变量时，另一个地址指向的变量也会改变； 五、js中的异常处理 基本格式： try{ //可能出现异常的代码 } catch(e){ //e就是出现异常的异常信息 //出现异常后的处理代码 } finally{ //不管有没有出现异常，都会执行的代码 //一般用来释放资源 } 如何手动抛出异常： throw 任何东西， catch中会抓到该东西 ","date":"2017-08-06","objectID":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%B8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:0:0","tags":["javascript基础知识复习"],"title":"javascript基础知识复习（一）基本概念","uri":"/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%B8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["JavaScript"],"content":" 自定义构造函数，在其原型对象上书写增删改查函数，再调用拼接字符串到HTML页面即可； 构造函数如下： function Mp3 (songs){//传入歌曲 this.songList=songs||\\[\\];//如果传入了歌曲就让歌曲数组等于他，否则等于空数组 // 要初始化界面 this.init(); } /*在它的原型对象中书写增删改查方法*/ Mp3.prototype={ // 已经替换了原型对象用constructor会丢失，需要手动设置 constructor:Mp3, /*书写初始化函数，进来时如果有数组，就要把他们拼接好并且全部显示到界面上*/ init:function(){ // render就是渲染的意思，我们要为他写函数 this.render(); }, render:function(){ // 把歌曲信息拼接好塞到父盒子里 var listDiv=document.querySelector('#c'); // 定义一个空数组用来装拼接的字符串 var strArr=\\[\\]; for (var i = 0; i \u003c this.songList.length; i++) { var song=this.songList\\[i\\]; //这里用push往数组里加这样一个字符串 strArr.push(' '+ ' '+song.name+' '+ ' '+song.singer+' '+ ' '); } //join() 方法用于把数组中的所有元素放入一个字符串,如果省略参数以逗号为分隔符 var str=strArr.join(''); listDiv.innerHTML=str; }, //增加 addSong:function(songName,singer){ if (!songName||!singer){ throw'内容不能为空！'; }; var temp={name:songName,singer:singer}; this.songList.push(temp); this.render(); return temp; }, // 删除 removeSong:function(songName){ var song=this.selectSong(songName); var index=this.songList.indexOf(song); // 判断有没有找到 if(index!=-1){ this.songList.splice(index,1); this.render(); return true; }else { return false; } }, // 改 updateSong:function(songName,singer){ var song=this.selectSong(songName); if(song==null){ return null; }else { song.singer=singer; this.render(); return song; } }, // 查 selectSong:function(songName){ for (var i = 0; i \u003c this.songList.length; i++) { var song=this.songList\\[i\\]; if(song.name==songName){ return song; } } return null; } }; ","date":"2017-08-06","objectID":"/%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E6%AD%8C%E6%9B%B2%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/:0:0","tags":["js"],"title":"用面向对象实现歌曲的增删改查","uri":"/%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E6%AD%8C%E6%9B%B2%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"},{"categories":["JavaScript"],"content":"老是忘，好好整理一下。 三大家族：offset（位移）、scroll（卷页）、client（可视区）。 ","date":"2017-08-01","objectID":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/:0:0","tags":["js"],"title":"js特效之三大家族、event事件","uri":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/"},{"categories":["JavaScript"],"content":"offset家族( 5个属性) offsetWidth和offsetHeight：检测盒子自身的宽高； 注意：包含盒子的padding和border。 offsetWidth=width+padding+border; offsetHeight=height+padding+border； offsetLeft和offsetTop：检测距离父盒子有定位的左侧和上面的距离； 注意：父盒子没有定位，往上找有定位的盒子，如果都没有以body为准，从父盒子的 padding开始算，border不算。 offsetParent：用于获取该元素中有定位的最近父级元素； 注意：如果当前元素的父级元素都没有进行定位,那么offsetParent为body。 （4）与style.width/height/top/left的比较； offset家族只可以只读，而style系列可以读写； offset家族返回的是数值类型（四舍五入），style系列返回的是字符串（带px），特殊情况：在父盒子有定位的情况下，offsetLeft==style.left（没有 px）; offsetLeft 和 offsetTop 可以返回没有定位的元素的left值和top值,而style 不可以。 ","date":"2017-08-01","objectID":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/:0:1","tags":["js"],"title":"js特效之三大家族、event事件","uri":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/"},{"categories":["JavaScript"],"content":"scroll家族（4个属性） scrollWidth和scrollHeight：检测内容的宽高； 注意：如果内容超出盒子，显示内容的高度，如果不超出盒子，IE567可以显示实际内 容宽高，IE8+火狐+谷歌显示盒子大小。 scrollTop和scrollLeft（有兼容性问题）：网页被浏览器遮住的头部和左边的部 分； 处理兼容性问题： - 未声明 DTD（谷歌只认识他）（火狐IE9+认识他） document.body.scrollTop/scrollLeft - 已经声明DTD（IE678只认识他）(火狐IE9+认识他) document.documentElement.scrollTop/scrollLeft - 火狐/谷歌/ie9+以上支持的(不管DTD) window.pageYOffest/pageXOffest 兼容性写法： var scrollTop = window.pageYOffset ||document.documentElement.scrollTop || document.body.scrollTop||0; 封装scroll方法 function Scroll() { return { “left”: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft || 0, “top”: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop || 0 }; } 用scroll().top或scroll().left来获取值。 ","date":"2017-08-01","objectID":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/:0:2","tags":["js"],"title":"js特效之三大家族、event事件","uri":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/"},{"categories":["JavaScript"],"content":"client家族（6个属性） clientWidth和clientHeight：网页可视区内容宽高； 注意：盒子调用：指盒子本身宽高（包括padding），HTML/body调用指可视区域大 小。 clientX和clientY:鼠标距离可视区域左侧、上面的距离(event调用）； clinetTop和clientLeft:盒子的border宽高； event事件：在触发某个事件时都会产生对象event，里面包含了一些事件信息。 为了兼容ie678，可以这样写 event=event||window.event; 其中有6重要属性： （1）pageX和pageY：光标在网页中的位置(距离左侧和上侧)；//参照点为左上角，算滚动区域 （2）screenX和screenYY：光标在屏幕中的位置(距离左侧和上侧)；//相对于屏幕 （3）clientX和clientY:光标在浏览器中位置(距离左侧和上侧)；//参照点为左上角，不会算上滚动区域 ","date":"2017-08-01","objectID":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/:0:3","tags":["js"],"title":"js特效之三大家族、event事件","uri":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/"},{"categories":["JavaScript"],"content":" 与一般轮播图不同，用缓动动画做，我们需要简单封装一个缓动框架 function animate (ele,json,fn){ clearInterval(ele.timer); ele.timer = setInterval(function () { //开闭原则 var bool = true; //遍历属性和值，分别单独处理json //attr == k(键) target == json\\[k\\](值) for(var k in json){//遍历Jason里面的属性k //四部 //获取他的属性时就需要单独处理 var leader; //如果获取里面的属性是opacity时 if(k===\"opacity\"){ leader=getStyle(ele,k)*100||1;//获取到的是小数0.3 }else { leader= parseInt(getStyle(ele,k)) || 0;//否则老样子 } leader + step; //3.赋值 //赋值时也要单独处理 if(k===\"opacity\"){ ele.style\\[k\\]=leader/100;//这种火狐chromeIE9以上都 可以 //兼容IE678 ele.style.filter=\"alpha(opacity=\"+leader+\")\";//这时leader是乘100的在这里透明度是以百分比 //如果是层级，一次性赋值成功，不需要缓动赋值 }else if (k===\"zIndex\"){ ele //1.获取步长 var step = (json\\[k\\] - leader)/10; //2.二次加工步长 step = step\u003e0?Math.ceil(step):Math.floor(step); leader =.style.zIndex=json\\[k\\]; } else { ele.style\\[k\\] = leader + \"px\"; } //4.清除定时器 //判断: 目标值和当前值的差大于步长，就不能跳出循环 //不考虑小数的情况：目标位置和当前位置不相等，就不能清除清除定时器。 if(json\\[k\\] !== leader){ bool = false; } } //只有所有的属性都到了指定位置，bool值才不会变成false； if(bool){ clearInterval(ele.timer); //所有程序执行完毕了，现在可以执行回调函数了 //只有传递了回调函数，才能执行 if(fn){ fn(); } } },25); } 兼容方法获取元素样式可以用这个 function getStyle(ele,attr){ if(window.getComputedStyle){ return window.getComputedStyle(ele,null)\\[attr\\]; } return ele.currentStyle\\[attr\\]; } 另外js中四中操作数组的方法： json.push();//在最后添加 json.pop();//删除最后一位 json.unshift();//在最前面添加 json.shift();//删除第一位 ","date":"2017-07-31","objectID":"/%E6%97%8B%E8%BD%AC%E8%BD%AE%E6%92%AD%E5%9B%BE/:0:0","tags":["js"],"title":"旋转轮播图","uri":"/%E6%97%8B%E8%BD%AC%E8%BD%AE%E6%92%AD%E5%9B%BE/"},{"categories":["Html"],"content":"在做的过程中，遇到自己忘了的，或者要注意的，都记下来了； 精灵图的定位的中心坐标是左上角； 去掉点击input后的边框：input：focus{outline：none}； 输入框和搜索框有间隙不对齐：可以给vertical-algin:middle,margin给负值； 小三角可以用css3中的transparent来做，比如下拉： .arrow{ width:0; height:0; border-left:20px solid transparent; border-right:20px solid transparent; border-top:20px solid #0066cc; } 也可以在父盒子里放一个菱形，让菱形偏移，父盒子截断； 顶栏中每个标签都有个小竖线，要用专门的li来放； z-index注意只对定位元素有效,正负数设置层叠关系； a标签一内嵌全乱了; 移动transfom,过渡效果transition; scrollTop兼容性写法： var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; 计时器效果 小时 var h=Math.floor(totalTime/3600); 分钟 var m=Math.floor(totalTime%3600/60); 秒 var s=totalTime%60; 在放li中时因为是两位，注意一个math.floor(h/10)，一个h%10； 网站的小图标在网站的后面加favicon.ico即可获得， link rel=“shortcut icon” href=\" favicon.ico\"的形式添加 梳理一下轮播图的思路： 如果有三张图，因为用到过渡效果，复制最后一个放在第一个前，第一个放在最后一个图后； 自动换图版：用transform移动一个图片宽度长度，用transition添加过渡效果，到第四张时，在过渡结束事件中将索引值改为1，并且为索引值添加对应类； 点击下方索引跳动版：添加onmouseover事件，为下标绑定一个自定义索引值用this.index形式，然后将这个新索引值给原来的图片的索引值； 左右点击版：右击index++，加上transform移动，transition过渡，左击一样；（在过渡结束事件中添加index\u003c1的情况） 鼠标在图片上或按钮上都要清除计时器，离开在启动计时器。 ","date":"2017-07-26","objectID":"/pc%E7%AB%AFjd%E9%A6%96%E9%A1%B5/:0:0","tags":["html"],"title":"PC端JD首页","uri":"/pc%E7%AB%AFjd%E9%A6%96%E9%A1%B5/"},{"categories":["工具"],"content":" Fireworks的常用快捷键： V：切换黑鼠标 U：画图 K：切片 I：吸色 Z：放大镜 空格：移动 shift：量尺寸 Photoshop的快捷键 z、alt：放大、缩小 空格：移动 u:矩形工具 ｉ：吸色 alt：切换辅助线 抠图：边框工具或者套索工具， Ctrl+c、Ctrl+v到新页面 ","date":"2017-07-24","objectID":"/fireworks-%E5%92%8Cps%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/:0:0","tags":["工具"],"title":"Fireworks 和Ps的常用操作","uri":"/fireworks-%E5%92%8Cps%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"categories":["Html"],"content":" bootstrap+less的页面，轮播图之前写的好烦， 而在bootstrap里面直接拿框架过来用，好方便的说。 传上来微金所的字体图标不显示了，我也不知道为啥/(ㄒoㄒ)/~~。 感受：很多的样式都可以在bootstrap里面都可以找到，直接拿过来用就好了，如果有一些不一样的，去bootstrap原样式里copy一份过来，类名为了不与原样式冲突改成自己的类名，然后自己在再根据具体情况修改就好了。 ","date":"2017-07-23","objectID":"/%E5%BE%AE%E9%87%91%E6%89%80%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%BC%8F/:0:0","tags":["boostrap"],"title":"微金所页面（响应式）","uri":"/%E5%BE%AE%E9%87%91%E6%89%80%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"categories":["工具"],"content":" LESSCSS是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。 LESSCSS可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。 在sublime中安装less插件（插件只是影响高亮效果） ctrl+shift+p\u003einstall Package\u003eless\u003e回车即可自动安装，开始我会出现下面这种提示：there is no package available,这时候只要去https://packagecontrol.io/installation#st2,下载 Package Control.sublime-package并且放到Sublime text安装目录下的Packages里面，重启即可。 （2）第二种安装方法是去网上下载好插件，然后放到sublime的插件文件夹里再重启即可； 去官网下好koala后安装，设置里选择简体中文，然后测试koala工具； 在同一个文件夹下建立两个文件：index.css和index.less文件，然后拖到koala里 然后在sublime中打开文件，在查看中打开两个窗口，左边是less，右边是css，less写好后Ctrl+s就会自动编译成css文件，如图说明编译成功； less的语法 http://www.1024i.com/demo/less/index.html 最近又看到node js 了，一般来说是这样编译的，先安装node.js,之后再全局安装less，那么lessc就是编译less文件的意思 再sublime中我们要装LESS、lessc、Less2Css三个插件，这样sublime会调用lessc去帮我们编译，在webstorm下一般他会智能提示你的。正常来讲，这种编译方式也是很少用得到的，如通less文件很多，我们不可能一边写，一边编译，所以我们可以引入一个less.js的文件，让js帮我们去解析即可（注意在引入less时，link的rel标签要改成stylesheet/less）。 ","date":"2017-07-20","objectID":"/%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8less%E5%92%8Ckoala%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/:0:0","tags":["less"],"title":"简单的使用less和koala编译工具","uri":"/%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8less%E5%92%8Ckoala%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"},{"categories":["mobile"],"content":" 做移动端的注意点 通栏中，不管多大的分辨率，左边和右边的距离都是不变的，我们可以将其input宽度设为100%，再在其父盒子中给出padding,父盒子不要给宽度； 很多时候样式都会被覆盖，在属性值后加上!important或者在前面加上其父级； sublime中alt+F3全局修改同一单词； 在浏览器中方向是从左往右，从上往下； 为了代码的通用性，动态获取dom元素，不能出现magicNumber; 用js设置自定义属性比如dataset[‘index’]，读取是this.dataset.index，但是用读取的值进行算数运算时不准确; 在选择器中，.header div指父盒子header下所有div；.header\u003ediv指父盒子header的所有下一级div; ","date":"2017-07-19","objectID":"/%E5%81%9A%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/:0:0","tags":["移动端"],"title":"做移动端的注意点","uri":"/%E5%81%9A%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"categories":["JavaScript"],"content":" 很多时候我们需要用到选项卡应用，比如手机京东的商品分类； js代码： window.onload=function(){ var tabLi=document.querySelectorAll('.tab li'); var tabDiv=document.querySelectorAll('.content Div'); for (var i = 0; i \u003c tabLi.length; i++) { tbLi[i].index=i; tabLi[i].onclick=function(){ for (var i = 0; i \u003c tabLi.length; i++) { tabLi[i].className=''; tabDiv[i].style.display='none'; } this.className='current'; tabDiv[this.index].style.display='block'; }; }; } ","date":"2017-07-19","objectID":"/%E9%80%89%E9%A1%B9%E5%8D%A1%E5%BA%94%E7%94%A8/:0:0","tags":["js"],"title":"选项卡应用","uri":"/%E9%80%89%E9%A1%B9%E5%8D%A1%E5%BA%94%E7%94%A8/"},{"categories":["CSS"],"content":" 伪类是给选择器添加效果；伪元素是给将特殊效果添加到选择器。 伪类的效果等同于伪造一个类，伪元素的效果等同于伪造一个元素 伪类： 伪元素： 在CSS3中规定：伪类用一个冒号来表示，伪元素用两个冒号来表示。 清除浮动有clearfix和clear，还有重构后的clearfix， clear不用了就是在容器内在所有标签后再加一个空的标签用clear：both；清除浮动，这样在浮动很多的页面中就会空很多的空标签； （ clearfix是在父容器的下方放一个空的div，用clear:both;来清除浮动 .clearfix::after { content: '.';//内容为.或空 display: block;//设为块级标签 clear: both;//清除浮动 visibility: hidden;//不可见 height: 0;//高度为0 font-size: 0;//字体大小为0 } （ 上面两种都是利用clear上方不能有浮动元素的规则来清除浮动的；重构后的clearfix是使父容器成为BFC（Block Formatting Context）， BFC特性之一就是可以包含浮动元素， 能形成BFC的有以下四种情形： float值不为none，可以是left，right或both overflow为hidden或auto或scroll display为inline-block或table-cell或table-caption position为absolute或fixed 所以下面两种方法都可以： （zoom：1是为了兼容ie6） .clearfix { zoom: 1; display: table; width: 100%; } .floatfix{ *zoom:1; } .floatfix:after{ content:\"\"; display:table; clear:both; } ","date":"2017-07-17","objectID":"/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0clearfixclear/:0:0","tags":["html"],"title":"伪类和伪元素、clearfix、clear","uri":"/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0clearfixclear/"},{"categories":["mobile"],"content":" 基本的静态布局 js效果：轮播图、倒计时、通栏透明度。 从Wordpress迁移到hexo后地址失效啦！ ","date":"2017-07-16","objectID":"/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%AC%E4%B8%9C%E9%A6%96%E9%A1%B5/:0:0","tags":["移动端"],"title":"移动端京东首页","uri":"/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%AC%E4%B8%9C%E9%A6%96%E9%A1%B5/"},{"categories":["mobile"],"content":" 移动端的touch主要用到一下三种： touchstart://手指放到屏幕上时触发 touchmove:指在屏幕上滑动式触发 touchend://手指离开屏幕时触发 每个触摸事件被触发后，会生成一个event对象， event//手对象里额外包括以下三个触摸列表 touches: //当前屏幕上所有手指的列表 targetTouches: //当前dom元素上手指的列表，尽量使用这个代替touches changedTouches: //涉及当前事件的手指的列表，尽量使用这个代替touches 这些列表里的每次触摸由touch对象组成， touch对象里包含着触摸信息， 主要属性如下： clientX / clientY: //触摸点相对浏览器窗口的位置 pageX / pageY: //触摸点相对于页面的位置 screenX / screenY: //触摸点相对于屏幕的位置 小案列： ","date":"2017-07-14","objectID":"/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84touch%E4%BA%8B%E4%BB%B6/:0:0","tags":["移动端"],"title":"移动端的touch事件","uri":"/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84touch%E4%BA%8B%E4%BB%B6/"},{"categories":["http/浏览器"],"content":" 浏览器的兼容性写法 -moz-对应 Firefox, -webkit-对应 Safari and Chrome -o- for Opera -ms- for Internet Explorer ","date":"2017-07-13","objectID":"/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E5%86%99%E6%B3%95/:0:0","tags":["浏览器前缀"],"title":"浏览器的兼容写法","uri":"/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E5%86%99%E6%B3%95/"},{"categories":["JavaScript"],"content":"js中css样式的不同 1、 JavaScript使用驼峰命名法，而css不是。 比如css中的‘border-radius’，js中的‘borderRadius’； 2、 JavaScript的属性值用字符串表示，而css不是。 比如js中div.style.backgroundColor='';css中div{}； ","date":"2017-07-13","objectID":"/js%E4%B8%AD%E7%9A%84css%E6%A0%B7%E5%BC%8F/:0:0","tags":["CSS"],"title":"Js中的css样式","uri":"/js%E4%B8%AD%E7%9A%84css%E6%A0%B7%E5%BC%8F/"},{"categories":["JavaScript"],"content":"1.了解offset家族，这里用到offsetLeft(盒子距离左侧的距离)，与style.left不同，style.left可被赋值且盒子要定位。动画原理：盒子本身的位置+位长，用offsetLeft来获取值，style.left来赋值。以下是动画的简单封装。 function animate(ele,target) { //每次调用计时器时都要清除计时器 clearInterval(ele.timer); //调用计时器 //位长让它有正有负 var speed=target\u003eele.offsetLeft ? 10:-10; ele.timer=setInterval(function () { var val=target-ele.offsetLeft; ele.style.left=ele.offsetLeft+speed+\"px\"; if(Math.abs(val)\u003c=10){ ele.style.left=target+\"px\"; clearInterval(ele.timer); } },30); } 2.思路：实现无缝滚动，先复制第一张图片到ul最后，当滚动到第六张时，将ul的offsetLeft值赋值为0（此时转到第一张），并将ul 的索引值赋值为1，切换到第二张，js代码如下： var all = document.getElementById(\"all\"); var screen = all.firstElementChild || all.firstChild;//all元素的第一个元素的第一个子节点 var imgWidth = screen.offsetWidth; var ul = screen.firstElementChild || screen.firstChild; var div = screen.lastElementChild || screen.lastChild; var spanArr = div.children; var ol = screen.children\\[1\\]; //2.复制第一张图片所在的li,添加到ul的最后面。 var ulNewLi = ul.children\\[0\\].cloneNode(true);//复制ul中第一个节点 ul.appendChild(ulNewLi);//添加到ul的最后,现在有6个li //3.给ol中添加li，ul中的个数-1个，并点亮第一个按钮。 for(var i=0;i\u003cul.children.length-1;i++){ var olNewLi = document.createElement(\"li\");//创建一个li列表 olNewLi.innerHTML=i+1;//在li列表里写上数字，并且要减一，因为他是从0开始的 ol.appendChild(olNewLi);//再把这个li添加到ol中去 } var olLiArr = ol.children;//找到ol中所有子节点 olLiArr\\[0\\].className=\"current\";//给第一个li添加一个类 //4.鼠标放到ol的li上切换图片 for(var i=0;i\u003colLiArr.length;i++){ //排他思想 olLiArr\\[i\\].index = i;//自定义属性，索引值绑定到index上 olLiArr\\[i\\].onmouseover = function () { for(var j=0;j\u003colLiArr.length;j++){ olLiArr\\[j\\].className=\"\"; } this.className=\"current\"; key=square=this.index; //要让定时器和索引值同步 animate(ul,-this.index*imgWidth); } } //5.添加定时器 var timer=setInterval(autoPlay,1000); var key=0; //定义两个定时器,都等于0 var square=0; function autoPlay() { key++; //我们要对两个计时器进行约束 if(key\u003eolLiArr.length){ ul.style.left=0;//图片滑动到最后一张接下来跳转到第一张，然后在滑动到第二张 key=1; } animate(ul,-key*imgWidth); square++; if(square\u003eolLiArr.length-1){ square=0; } for (var i=0;i\u003colLiArr.length;i++){//用排他思想 olLiArr\\[i\\].className=\"\";//全都排除 } olLiArr\\[square\\].className=\"current\";//移到哪边，哪边就就有这个属性 } //鼠标放上去清除定时器，离开启动定时器 all.onmouseover=function () { clearInterval(timer); } all.onmouseout=function () { setInterval(autoPlay,1000); } //6.左右切换图片（鼠标放上去隐藏，移开显示） all.onmouseover=function () { div.style.display=\"block\" clearInterval(timer); } all.onmouseout=function () { div.style.display=\"none\" timer=setInterval(autoPlay,1000); } spanArr\\[0\\].onclick=function () { key--; //我们要对两个计时器进行约束 if(key\u003c0){ ul.style.left=-imgWidth*(olLiArr.length)+\"px\"; //现在给他5个图片的移动距离且是负值，让它一下子跳到最后最后一张图片 key=olLiArr.length-1; } animate(ul,-key*imgWidth); square--; if(square\u003c0){ square=olLiArr.length-1; } for (var i=0;i\u003colLiArr.length;i++){ //用排他思想 olLiArr\\[i\\].className=\"\";//全都排除 } olLiArr\\[square\\].className=\"current\"; } spanArr\\[1\\].onclick=function () { autoPlay(); } //移动分装 function animate(ele,target) { clearInterval(ele.timer); var speed=target\u003eele.offsetLeft ? 10:-10; ele.timer=setInterval(function () { var val=target-ele.offsetLeft; ele.style.left=ele.offsetLeft+speed+\"px\"; if(Math.abs(val)\u003c=10){ ele.style.left=target+\"px\"; clearInterval(ele.timer); } },10); } ","date":"2017-05-21","objectID":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E5%B8%A6%E6%9C%89%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD%E5%9B%BEoffset%E5%AE%B6%E6%97%8F/:0:0","tags":["js"],"title":"js特效之带有定时器的无缝轮播图（offset家族）","uri":"/js%E7%89%B9%E6%95%88%E4%B9%8B%E5%B8%A6%E6%9C%89%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD%E5%9B%BEoffset%E5%AE%B6%E6%97%8F/"},{"categories":null,"content":"简介 web开发者,擅长前端开发,熟悉掌握React/Vue/Typescript,正在学习java/go. 热爱新技术,热爱运动,热爱生活. ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"技术优势 熟悉JavaScript,包括其相关原理,熟悉TypeScript; 熟悉 React相关技术栈,了解React核心原理(双缓存,Diff算法,Fiber,Hook等); 熟悉Vue相关技术栈(包括Vue2和Vue3); 熟悉掌握Webpack相关构建工具; 掌握Http协议,了解一些前端安全防范; ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"关于本站 2017年5月份，我购买了老薛主机的服务器和chenxiaolani域名，搭建了wordpress（我的第一个站点）； 2018年6月份，在参加工作不久后，由于精力有限，加之服务器到期，我将博客迁移到了Hexo平台； 2020年6月份，随时间推移，越来越体会到Hexo的不便，我将博客迁移到了更加轻量的Hugo； 未完待续… ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"友情链接 轩陌博客 个人笔记、技术分享，低代码方向 samkallon 技术分享 \u0026\u0026 生活日常 ","date":"0001-01-01","objectID":"/link/:1:0","tags":null,"title":"","uri":"/link/"}]